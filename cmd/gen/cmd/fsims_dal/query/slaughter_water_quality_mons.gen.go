// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"CN-EU-FSIMS/internal/app/models/slaughter"
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"
)

func newSlaughterWaterQualityMon(db *gorm.DB, opts ...gen.DOOption) slaughterWaterQualityMon {
	_slaughterWaterQualityMon := slaughterWaterQualityMon{}

	_slaughterWaterQualityMon.slaughterWaterQualityMonDo.UseDB(db, opts...)
	_slaughterWaterQualityMon.slaughterWaterQualityMonDo.UseModel(&slaughter.SlaughterWaterQualityMon{})

	tableName := _slaughterWaterQualityMon.slaughterWaterQualityMonDo.TableName()
	_slaughterWaterQualityMon.ALL = field.NewAsterisk(tableName)
	_slaughterWaterQualityMon.ID = field.NewUint(tableName, "id")
	_slaughterWaterQualityMon.CreatedAt = field.NewTime(tableName, "created_at")
	_slaughterWaterQualityMon.UpdatedAt = field.NewTime(tableName, "updated_at")
	_slaughterWaterQualityMon.DeletedAt = field.NewField(tableName, "deleted_at")
	_slaughterWaterQualityMon.HouseNumber = field.NewString(tableName, "house_number")
	_slaughterWaterQualityMon.TimeRecordAt = field.NewTime(tableName, "time_record_at")
	_slaughterWaterQualityMon.SlaughterWaterMicroIndex = slaughterWaterQualityMonHasOneSlaughterWaterMicroIndex{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("SlaughterWaterMicroIndex", "slaughter.SlaughterWaterMicroIndex"),
	}

	_slaughterWaterQualityMon.OapGciSla = slaughterWaterQualityMonHasOneOapGciSla{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("OapGciSla", "slaughter.OapGciSla"),
	}

	_slaughterWaterQualityMon.ToxinIndexSla = slaughterWaterQualityMonHasOneToxinIndexSla{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("ToxinIndexSla", "slaughter.SlaughterToxinIndex"),
		SlaughterWaterToxinIndex: struct {
			field.RelationField
		}{
			RelationField: field.NewRelation("ToxinIndexSla.SlaughterWaterToxinIndex", "slaughter.SlaughterWaterToxinIndex"),
		},
	}

	_slaughterWaterQualityMon.fillFieldMap()

	return _slaughterWaterQualityMon
}

type slaughterWaterQualityMon struct {
	slaughterWaterQualityMonDo slaughterWaterQualityMonDo

	ALL                      field.Asterisk
	ID                       field.Uint
	CreatedAt                field.Time
	UpdatedAt                field.Time
	DeletedAt                field.Field
	HouseNumber              field.String
	TimeRecordAt             field.Time
	SlaughterWaterMicroIndex slaughterWaterQualityMonHasOneSlaughterWaterMicroIndex

	OapGciSla slaughterWaterQualityMonHasOneOapGciSla

	ToxinIndexSla slaughterWaterQualityMonHasOneToxinIndexSla

	fieldMap map[string]field.Expr
}

func (s slaughterWaterQualityMon) Table(newTableName string) *slaughterWaterQualityMon {
	s.slaughterWaterQualityMonDo.UseTable(newTableName)
	return s.updateTableName(newTableName)
}

func (s slaughterWaterQualityMon) As(alias string) *slaughterWaterQualityMon {
	s.slaughterWaterQualityMonDo.DO = *(s.slaughterWaterQualityMonDo.As(alias).(*gen.DO))
	return s.updateTableName(alias)
}

func (s *slaughterWaterQualityMon) updateTableName(table string) *slaughterWaterQualityMon {
	s.ALL = field.NewAsterisk(table)
	s.ID = field.NewUint(table, "id")
	s.CreatedAt = field.NewTime(table, "created_at")
	s.UpdatedAt = field.NewTime(table, "updated_at")
	s.DeletedAt = field.NewField(table, "deleted_at")
	s.HouseNumber = field.NewString(table, "house_number")
	s.TimeRecordAt = field.NewTime(table, "time_record_at")

	s.fillFieldMap()

	return s
}

func (s *slaughterWaterQualityMon) WithContext(ctx context.Context) ISlaughterWaterQualityMonDo {
	return s.slaughterWaterQualityMonDo.WithContext(ctx)
}

func (s slaughterWaterQualityMon) TableName() string { return s.slaughterWaterQualityMonDo.TableName() }

func (s slaughterWaterQualityMon) Alias() string { return s.slaughterWaterQualityMonDo.Alias() }

func (s slaughterWaterQualityMon) Columns(cols ...field.Expr) gen.Columns {
	return s.slaughterWaterQualityMonDo.Columns(cols...)
}

func (s *slaughterWaterQualityMon) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := s.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (s *slaughterWaterQualityMon) fillFieldMap() {
	s.fieldMap = make(map[string]field.Expr, 9)
	s.fieldMap["id"] = s.ID
	s.fieldMap["created_at"] = s.CreatedAt
	s.fieldMap["updated_at"] = s.UpdatedAt
	s.fieldMap["deleted_at"] = s.DeletedAt
	s.fieldMap["house_number"] = s.HouseNumber
	s.fieldMap["time_record_at"] = s.TimeRecordAt

}

func (s slaughterWaterQualityMon) clone(db *gorm.DB) slaughterWaterQualityMon {
	s.slaughterWaterQualityMonDo.ReplaceConnPool(db.Statement.ConnPool)
	return s
}

func (s slaughterWaterQualityMon) replaceDB(db *gorm.DB) slaughterWaterQualityMon {
	s.slaughterWaterQualityMonDo.ReplaceDB(db)
	return s
}

type slaughterWaterQualityMonHasOneSlaughterWaterMicroIndex struct {
	db *gorm.DB

	field.RelationField
}

func (a slaughterWaterQualityMonHasOneSlaughterWaterMicroIndex) Where(conds ...field.Expr) *slaughterWaterQualityMonHasOneSlaughterWaterMicroIndex {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a slaughterWaterQualityMonHasOneSlaughterWaterMicroIndex) WithContext(ctx context.Context) *slaughterWaterQualityMonHasOneSlaughterWaterMicroIndex {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a slaughterWaterQualityMonHasOneSlaughterWaterMicroIndex) Session(session *gorm.Session) *slaughterWaterQualityMonHasOneSlaughterWaterMicroIndex {
	a.db = a.db.Session(session)
	return &a
}

func (a slaughterWaterQualityMonHasOneSlaughterWaterMicroIndex) Model(m *slaughter.SlaughterWaterQualityMon) *slaughterWaterQualityMonHasOneSlaughterWaterMicroIndexTx {
	return &slaughterWaterQualityMonHasOneSlaughterWaterMicroIndexTx{a.db.Model(m).Association(a.Name())}
}

type slaughterWaterQualityMonHasOneSlaughterWaterMicroIndexTx struct{ tx *gorm.Association }

func (a slaughterWaterQualityMonHasOneSlaughterWaterMicroIndexTx) Find() (result *slaughter.SlaughterWaterMicroIndex, err error) {
	return result, a.tx.Find(&result)
}

func (a slaughterWaterQualityMonHasOneSlaughterWaterMicroIndexTx) Append(values ...*slaughter.SlaughterWaterMicroIndex) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a slaughterWaterQualityMonHasOneSlaughterWaterMicroIndexTx) Replace(values ...*slaughter.SlaughterWaterMicroIndex) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a slaughterWaterQualityMonHasOneSlaughterWaterMicroIndexTx) Delete(values ...*slaughter.SlaughterWaterMicroIndex) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a slaughterWaterQualityMonHasOneSlaughterWaterMicroIndexTx) Clear() error {
	return a.tx.Clear()
}

func (a slaughterWaterQualityMonHasOneSlaughterWaterMicroIndexTx) Count() int64 {
	return a.tx.Count()
}

type slaughterWaterQualityMonHasOneOapGciSla struct {
	db *gorm.DB

	field.RelationField
}

func (a slaughterWaterQualityMonHasOneOapGciSla) Where(conds ...field.Expr) *slaughterWaterQualityMonHasOneOapGciSla {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a slaughterWaterQualityMonHasOneOapGciSla) WithContext(ctx context.Context) *slaughterWaterQualityMonHasOneOapGciSla {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a slaughterWaterQualityMonHasOneOapGciSla) Session(session *gorm.Session) *slaughterWaterQualityMonHasOneOapGciSla {
	a.db = a.db.Session(session)
	return &a
}

func (a slaughterWaterQualityMonHasOneOapGciSla) Model(m *slaughter.SlaughterWaterQualityMon) *slaughterWaterQualityMonHasOneOapGciSlaTx {
	return &slaughterWaterQualityMonHasOneOapGciSlaTx{a.db.Model(m).Association(a.Name())}
}

type slaughterWaterQualityMonHasOneOapGciSlaTx struct{ tx *gorm.Association }

func (a slaughterWaterQualityMonHasOneOapGciSlaTx) Find() (result *slaughter.OapGciSla, err error) {
	return result, a.tx.Find(&result)
}

func (a slaughterWaterQualityMonHasOneOapGciSlaTx) Append(values ...*slaughter.OapGciSla) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a slaughterWaterQualityMonHasOneOapGciSlaTx) Replace(values ...*slaughter.OapGciSla) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a slaughterWaterQualityMonHasOneOapGciSlaTx) Delete(values ...*slaughter.OapGciSla) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a slaughterWaterQualityMonHasOneOapGciSlaTx) Clear() error {
	return a.tx.Clear()
}

func (a slaughterWaterQualityMonHasOneOapGciSlaTx) Count() int64 {
	return a.tx.Count()
}

type slaughterWaterQualityMonHasOneToxinIndexSla struct {
	db *gorm.DB

	field.RelationField

	SlaughterWaterToxinIndex struct {
		field.RelationField
	}
}

func (a slaughterWaterQualityMonHasOneToxinIndexSla) Where(conds ...field.Expr) *slaughterWaterQualityMonHasOneToxinIndexSla {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a slaughterWaterQualityMonHasOneToxinIndexSla) WithContext(ctx context.Context) *slaughterWaterQualityMonHasOneToxinIndexSla {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a slaughterWaterQualityMonHasOneToxinIndexSla) Session(session *gorm.Session) *slaughterWaterQualityMonHasOneToxinIndexSla {
	a.db = a.db.Session(session)
	return &a
}

func (a slaughterWaterQualityMonHasOneToxinIndexSla) Model(m *slaughter.SlaughterWaterQualityMon) *slaughterWaterQualityMonHasOneToxinIndexSlaTx {
	return &slaughterWaterQualityMonHasOneToxinIndexSlaTx{a.db.Model(m).Association(a.Name())}
}

type slaughterWaterQualityMonHasOneToxinIndexSlaTx struct{ tx *gorm.Association }

func (a slaughterWaterQualityMonHasOneToxinIndexSlaTx) Find() (result *slaughter.SlaughterToxinIndex, err error) {
	return result, a.tx.Find(&result)
}

func (a slaughterWaterQualityMonHasOneToxinIndexSlaTx) Append(values ...*slaughter.SlaughterToxinIndex) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a slaughterWaterQualityMonHasOneToxinIndexSlaTx) Replace(values ...*slaughter.SlaughterToxinIndex) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a slaughterWaterQualityMonHasOneToxinIndexSlaTx) Delete(values ...*slaughter.SlaughterToxinIndex) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a slaughterWaterQualityMonHasOneToxinIndexSlaTx) Clear() error {
	return a.tx.Clear()
}

func (a slaughterWaterQualityMonHasOneToxinIndexSlaTx) Count() int64 {
	return a.tx.Count()
}

type slaughterWaterQualityMonDo struct{ gen.DO }

type ISlaughterWaterQualityMonDo interface {
	gen.SubQuery
	Debug() ISlaughterWaterQualityMonDo
	WithContext(ctx context.Context) ISlaughterWaterQualityMonDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() ISlaughterWaterQualityMonDo
	WriteDB() ISlaughterWaterQualityMonDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) ISlaughterWaterQualityMonDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) ISlaughterWaterQualityMonDo
	Not(conds ...gen.Condition) ISlaughterWaterQualityMonDo
	Or(conds ...gen.Condition) ISlaughterWaterQualityMonDo
	Select(conds ...field.Expr) ISlaughterWaterQualityMonDo
	Where(conds ...gen.Condition) ISlaughterWaterQualityMonDo
	Order(conds ...field.Expr) ISlaughterWaterQualityMonDo
	Distinct(cols ...field.Expr) ISlaughterWaterQualityMonDo
	Omit(cols ...field.Expr) ISlaughterWaterQualityMonDo
	Join(table schema.Tabler, on ...field.Expr) ISlaughterWaterQualityMonDo
	LeftJoin(table schema.Tabler, on ...field.Expr) ISlaughterWaterQualityMonDo
	RightJoin(table schema.Tabler, on ...field.Expr) ISlaughterWaterQualityMonDo
	Group(cols ...field.Expr) ISlaughterWaterQualityMonDo
	Having(conds ...gen.Condition) ISlaughterWaterQualityMonDo
	Limit(limit int) ISlaughterWaterQualityMonDo
	Offset(offset int) ISlaughterWaterQualityMonDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) ISlaughterWaterQualityMonDo
	Unscoped() ISlaughterWaterQualityMonDo
	Create(values ...*slaughter.SlaughterWaterQualityMon) error
	CreateInBatches(values []*slaughter.SlaughterWaterQualityMon, batchSize int) error
	Save(values ...*slaughter.SlaughterWaterQualityMon) error
	First() (*slaughter.SlaughterWaterQualityMon, error)
	Take() (*slaughter.SlaughterWaterQualityMon, error)
	Last() (*slaughter.SlaughterWaterQualityMon, error)
	Find() ([]*slaughter.SlaughterWaterQualityMon, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*slaughter.SlaughterWaterQualityMon, err error)
	FindInBatches(result *[]*slaughter.SlaughterWaterQualityMon, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*slaughter.SlaughterWaterQualityMon) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) ISlaughterWaterQualityMonDo
	Assign(attrs ...field.AssignExpr) ISlaughterWaterQualityMonDo
	Joins(fields ...field.RelationField) ISlaughterWaterQualityMonDo
	Preload(fields ...field.RelationField) ISlaughterWaterQualityMonDo
	FirstOrInit() (*slaughter.SlaughterWaterQualityMon, error)
	FirstOrCreate() (*slaughter.SlaughterWaterQualityMon, error)
	FindByPage(offset int, limit int) (result []*slaughter.SlaughterWaterQualityMon, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) ISlaughterWaterQualityMonDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (s slaughterWaterQualityMonDo) Debug() ISlaughterWaterQualityMonDo {
	return s.withDO(s.DO.Debug())
}

func (s slaughterWaterQualityMonDo) WithContext(ctx context.Context) ISlaughterWaterQualityMonDo {
	return s.withDO(s.DO.WithContext(ctx))
}

func (s slaughterWaterQualityMonDo) ReadDB() ISlaughterWaterQualityMonDo {
	return s.Clauses(dbresolver.Read)
}

func (s slaughterWaterQualityMonDo) WriteDB() ISlaughterWaterQualityMonDo {
	return s.Clauses(dbresolver.Write)
}

func (s slaughterWaterQualityMonDo) Session(config *gorm.Session) ISlaughterWaterQualityMonDo {
	return s.withDO(s.DO.Session(config))
}

func (s slaughterWaterQualityMonDo) Clauses(conds ...clause.Expression) ISlaughterWaterQualityMonDo {
	return s.withDO(s.DO.Clauses(conds...))
}

func (s slaughterWaterQualityMonDo) Returning(value interface{}, columns ...string) ISlaughterWaterQualityMonDo {
	return s.withDO(s.DO.Returning(value, columns...))
}

func (s slaughterWaterQualityMonDo) Not(conds ...gen.Condition) ISlaughterWaterQualityMonDo {
	return s.withDO(s.DO.Not(conds...))
}

func (s slaughterWaterQualityMonDo) Or(conds ...gen.Condition) ISlaughterWaterQualityMonDo {
	return s.withDO(s.DO.Or(conds...))
}

func (s slaughterWaterQualityMonDo) Select(conds ...field.Expr) ISlaughterWaterQualityMonDo {
	return s.withDO(s.DO.Select(conds...))
}

func (s slaughterWaterQualityMonDo) Where(conds ...gen.Condition) ISlaughterWaterQualityMonDo {
	return s.withDO(s.DO.Where(conds...))
}

func (s slaughterWaterQualityMonDo) Order(conds ...field.Expr) ISlaughterWaterQualityMonDo {
	return s.withDO(s.DO.Order(conds...))
}

func (s slaughterWaterQualityMonDo) Distinct(cols ...field.Expr) ISlaughterWaterQualityMonDo {
	return s.withDO(s.DO.Distinct(cols...))
}

func (s slaughterWaterQualityMonDo) Omit(cols ...field.Expr) ISlaughterWaterQualityMonDo {
	return s.withDO(s.DO.Omit(cols...))
}

func (s slaughterWaterQualityMonDo) Join(table schema.Tabler, on ...field.Expr) ISlaughterWaterQualityMonDo {
	return s.withDO(s.DO.Join(table, on...))
}

func (s slaughterWaterQualityMonDo) LeftJoin(table schema.Tabler, on ...field.Expr) ISlaughterWaterQualityMonDo {
	return s.withDO(s.DO.LeftJoin(table, on...))
}

func (s slaughterWaterQualityMonDo) RightJoin(table schema.Tabler, on ...field.Expr) ISlaughterWaterQualityMonDo {
	return s.withDO(s.DO.RightJoin(table, on...))
}

func (s slaughterWaterQualityMonDo) Group(cols ...field.Expr) ISlaughterWaterQualityMonDo {
	return s.withDO(s.DO.Group(cols...))
}

func (s slaughterWaterQualityMonDo) Having(conds ...gen.Condition) ISlaughterWaterQualityMonDo {
	return s.withDO(s.DO.Having(conds...))
}

func (s slaughterWaterQualityMonDo) Limit(limit int) ISlaughterWaterQualityMonDo {
	return s.withDO(s.DO.Limit(limit))
}

func (s slaughterWaterQualityMonDo) Offset(offset int) ISlaughterWaterQualityMonDo {
	return s.withDO(s.DO.Offset(offset))
}

func (s slaughterWaterQualityMonDo) Scopes(funcs ...func(gen.Dao) gen.Dao) ISlaughterWaterQualityMonDo {
	return s.withDO(s.DO.Scopes(funcs...))
}

func (s slaughterWaterQualityMonDo) Unscoped() ISlaughterWaterQualityMonDo {
	return s.withDO(s.DO.Unscoped())
}

func (s slaughterWaterQualityMonDo) Create(values ...*slaughter.SlaughterWaterQualityMon) error {
	if len(values) == 0 {
		return nil
	}
	return s.DO.Create(values)
}

func (s slaughterWaterQualityMonDo) CreateInBatches(values []*slaughter.SlaughterWaterQualityMon, batchSize int) error {
	return s.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (s slaughterWaterQualityMonDo) Save(values ...*slaughter.SlaughterWaterQualityMon) error {
	if len(values) == 0 {
		return nil
	}
	return s.DO.Save(values)
}

func (s slaughterWaterQualityMonDo) First() (*slaughter.SlaughterWaterQualityMon, error) {
	if result, err := s.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*slaughter.SlaughterWaterQualityMon), nil
	}
}

func (s slaughterWaterQualityMonDo) Take() (*slaughter.SlaughterWaterQualityMon, error) {
	if result, err := s.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*slaughter.SlaughterWaterQualityMon), nil
	}
}

func (s slaughterWaterQualityMonDo) Last() (*slaughter.SlaughterWaterQualityMon, error) {
	if result, err := s.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*slaughter.SlaughterWaterQualityMon), nil
	}
}

func (s slaughterWaterQualityMonDo) Find() ([]*slaughter.SlaughterWaterQualityMon, error) {
	result, err := s.DO.Find()
	return result.([]*slaughter.SlaughterWaterQualityMon), err
}

func (s slaughterWaterQualityMonDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*slaughter.SlaughterWaterQualityMon, err error) {
	buf := make([]*slaughter.SlaughterWaterQualityMon, 0, batchSize)
	err = s.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (s slaughterWaterQualityMonDo) FindInBatches(result *[]*slaughter.SlaughterWaterQualityMon, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return s.DO.FindInBatches(result, batchSize, fc)
}

func (s slaughterWaterQualityMonDo) Attrs(attrs ...field.AssignExpr) ISlaughterWaterQualityMonDo {
	return s.withDO(s.DO.Attrs(attrs...))
}

func (s slaughterWaterQualityMonDo) Assign(attrs ...field.AssignExpr) ISlaughterWaterQualityMonDo {
	return s.withDO(s.DO.Assign(attrs...))
}

func (s slaughterWaterQualityMonDo) Joins(fields ...field.RelationField) ISlaughterWaterQualityMonDo {
	for _, _f := range fields {
		s = *s.withDO(s.DO.Joins(_f))
	}
	return &s
}

func (s slaughterWaterQualityMonDo) Preload(fields ...field.RelationField) ISlaughterWaterQualityMonDo {
	for _, _f := range fields {
		s = *s.withDO(s.DO.Preload(_f))
	}
	return &s
}

func (s slaughterWaterQualityMonDo) FirstOrInit() (*slaughter.SlaughterWaterQualityMon, error) {
	if result, err := s.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*slaughter.SlaughterWaterQualityMon), nil
	}
}

func (s slaughterWaterQualityMonDo) FirstOrCreate() (*slaughter.SlaughterWaterQualityMon, error) {
	if result, err := s.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*slaughter.SlaughterWaterQualityMon), nil
	}
}

func (s slaughterWaterQualityMonDo) FindByPage(offset int, limit int) (result []*slaughter.SlaughterWaterQualityMon, count int64, err error) {
	result, err = s.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = s.Offset(-1).Limit(-1).Count()
	return
}

func (s slaughterWaterQualityMonDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = s.Count()
	if err != nil {
		return
	}

	err = s.Offset(offset).Limit(limit).Scan(result)
	return
}

func (s slaughterWaterQualityMonDo) Scan(result interface{}) (err error) {
	return s.DO.Scan(result)
}

func (s slaughterWaterQualityMonDo) Delete(models ...*slaughter.SlaughterWaterQualityMon) (result gen.ResultInfo, err error) {
	return s.DO.Delete(models)
}

func (s *slaughterWaterQualityMonDo) withDO(do gen.Dao) *slaughterWaterQualityMonDo {
	s.DO = *do.(*gen.DO)
	return s
}
