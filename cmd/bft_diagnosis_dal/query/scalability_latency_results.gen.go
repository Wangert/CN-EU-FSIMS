// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"CN-EU-FSIMS/cmd/bft_diagnosis_dal/model"
)

func newScalabilityLatencyResult(db *gorm.DB, opts ...gen.DOOption) scalabilityLatencyResult {
	_scalabilityLatencyResult := scalabilityLatencyResult{}

	_scalabilityLatencyResult.scalabilityLatencyResultDo.UseDB(db, opts...)
	_scalabilityLatencyResult.scalabilityLatencyResultDo.UseModel(&model.ScalabilityLatencyResult{})

	tableName := _scalabilityLatencyResult.scalabilityLatencyResultDo.TableName()
	_scalabilityLatencyResult.ALL = field.NewAsterisk(tableName)
	_scalabilityLatencyResult.ID = field.NewInt32(tableName, "id")
	_scalabilityLatencyResult.Item = field.NewString(tableName, "item")
	_scalabilityLatencyResult.PeerID = field.NewString(tableName, "peer_id")
	_scalabilityLatencyResult.RequestCmd = field.NewString(tableName, "request_cmd")
	_scalabilityLatencyResult.RequestTimestamp = field.NewInt64(tableName, "request_timestamp")
	_scalabilityLatencyResult.Latency = field.NewInt32(tableName, "latency")

	_scalabilityLatencyResult.fillFieldMap()

	return _scalabilityLatencyResult
}

type scalabilityLatencyResult struct {
	scalabilityLatencyResultDo scalabilityLatencyResultDo

	ALL              field.Asterisk
	ID               field.Int32
	Item             field.String
	PeerID           field.String
	RequestCmd       field.String
	RequestTimestamp field.Int64
	Latency          field.Int32

	fieldMap map[string]field.Expr
}

func (s scalabilityLatencyResult) Table(newTableName string) *scalabilityLatencyResult {
	s.scalabilityLatencyResultDo.UseTable(newTableName)
	return s.updateTableName(newTableName)
}

func (s scalabilityLatencyResult) As(alias string) *scalabilityLatencyResult {
	s.scalabilityLatencyResultDo.DO = *(s.scalabilityLatencyResultDo.As(alias).(*gen.DO))
	return s.updateTableName(alias)
}

func (s *scalabilityLatencyResult) updateTableName(table string) *scalabilityLatencyResult {
	s.ALL = field.NewAsterisk(table)
	s.ID = field.NewInt32(table, "id")
	s.Item = field.NewString(table, "item")
	s.PeerID = field.NewString(table, "peer_id")
	s.RequestCmd = field.NewString(table, "request_cmd")
	s.RequestTimestamp = field.NewInt64(table, "request_timestamp")
	s.Latency = field.NewInt32(table, "latency")

	s.fillFieldMap()

	return s
}

func (s *scalabilityLatencyResult) WithContext(ctx context.Context) IScalabilityLatencyResultDo {
	return s.scalabilityLatencyResultDo.WithContext(ctx)
}

func (s scalabilityLatencyResult) TableName() string { return s.scalabilityLatencyResultDo.TableName() }

func (s scalabilityLatencyResult) Alias() string { return s.scalabilityLatencyResultDo.Alias() }

func (s scalabilityLatencyResult) Columns(cols ...field.Expr) gen.Columns {
	return s.scalabilityLatencyResultDo.Columns(cols...)
}

func (s *scalabilityLatencyResult) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := s.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (s *scalabilityLatencyResult) fillFieldMap() {
	s.fieldMap = make(map[string]field.Expr, 6)
	s.fieldMap["id"] = s.ID
	s.fieldMap["item"] = s.Item
	s.fieldMap["peer_id"] = s.PeerID
	s.fieldMap["request_cmd"] = s.RequestCmd
	s.fieldMap["request_timestamp"] = s.RequestTimestamp
	s.fieldMap["latency"] = s.Latency
}

func (s scalabilityLatencyResult) clone(db *gorm.DB) scalabilityLatencyResult {
	s.scalabilityLatencyResultDo.ReplaceConnPool(db.Statement.ConnPool)
	return s
}

func (s scalabilityLatencyResult) replaceDB(db *gorm.DB) scalabilityLatencyResult {
	s.scalabilityLatencyResultDo.ReplaceDB(db)
	return s
}

type scalabilityLatencyResultDo struct{ gen.DO }

type IScalabilityLatencyResultDo interface {
	gen.SubQuery
	Debug() IScalabilityLatencyResultDo
	WithContext(ctx context.Context) IScalabilityLatencyResultDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IScalabilityLatencyResultDo
	WriteDB() IScalabilityLatencyResultDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IScalabilityLatencyResultDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IScalabilityLatencyResultDo
	Not(conds ...gen.Condition) IScalabilityLatencyResultDo
	Or(conds ...gen.Condition) IScalabilityLatencyResultDo
	Select(conds ...field.Expr) IScalabilityLatencyResultDo
	Where(conds ...gen.Condition) IScalabilityLatencyResultDo
	Order(conds ...field.Expr) IScalabilityLatencyResultDo
	Distinct(cols ...field.Expr) IScalabilityLatencyResultDo
	Omit(cols ...field.Expr) IScalabilityLatencyResultDo
	Join(table schema.Tabler, on ...field.Expr) IScalabilityLatencyResultDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IScalabilityLatencyResultDo
	RightJoin(table schema.Tabler, on ...field.Expr) IScalabilityLatencyResultDo
	Group(cols ...field.Expr) IScalabilityLatencyResultDo
	Having(conds ...gen.Condition) IScalabilityLatencyResultDo
	Limit(limit int) IScalabilityLatencyResultDo
	Offset(offset int) IScalabilityLatencyResultDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IScalabilityLatencyResultDo
	Unscoped() IScalabilityLatencyResultDo
	Create(values ...*model.ScalabilityLatencyResult) error
	CreateInBatches(values []*model.ScalabilityLatencyResult, batchSize int) error
	Save(values ...*model.ScalabilityLatencyResult) error
	First() (*model.ScalabilityLatencyResult, error)
	Take() (*model.ScalabilityLatencyResult, error)
	Last() (*model.ScalabilityLatencyResult, error)
	Find() ([]*model.ScalabilityLatencyResult, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.ScalabilityLatencyResult, err error)
	FindInBatches(result *[]*model.ScalabilityLatencyResult, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.ScalabilityLatencyResult) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IScalabilityLatencyResultDo
	Assign(attrs ...field.AssignExpr) IScalabilityLatencyResultDo
	Joins(fields ...field.RelationField) IScalabilityLatencyResultDo
	Preload(fields ...field.RelationField) IScalabilityLatencyResultDo
	FirstOrInit() (*model.ScalabilityLatencyResult, error)
	FirstOrCreate() (*model.ScalabilityLatencyResult, error)
	FindByPage(offset int, limit int) (result []*model.ScalabilityLatencyResult, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IScalabilityLatencyResultDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (s scalabilityLatencyResultDo) Debug() IScalabilityLatencyResultDo {
	return s.withDO(s.DO.Debug())
}

func (s scalabilityLatencyResultDo) WithContext(ctx context.Context) IScalabilityLatencyResultDo {
	return s.withDO(s.DO.WithContext(ctx))
}

func (s scalabilityLatencyResultDo) ReadDB() IScalabilityLatencyResultDo {
	return s.Clauses(dbresolver.Read)
}

func (s scalabilityLatencyResultDo) WriteDB() IScalabilityLatencyResultDo {
	return s.Clauses(dbresolver.Write)
}

func (s scalabilityLatencyResultDo) Session(config *gorm.Session) IScalabilityLatencyResultDo {
	return s.withDO(s.DO.Session(config))
}

func (s scalabilityLatencyResultDo) Clauses(conds ...clause.Expression) IScalabilityLatencyResultDo {
	return s.withDO(s.DO.Clauses(conds...))
}

func (s scalabilityLatencyResultDo) Returning(value interface{}, columns ...string) IScalabilityLatencyResultDo {
	return s.withDO(s.DO.Returning(value, columns...))
}

func (s scalabilityLatencyResultDo) Not(conds ...gen.Condition) IScalabilityLatencyResultDo {
	return s.withDO(s.DO.Not(conds...))
}

func (s scalabilityLatencyResultDo) Or(conds ...gen.Condition) IScalabilityLatencyResultDo {
	return s.withDO(s.DO.Or(conds...))
}

func (s scalabilityLatencyResultDo) Select(conds ...field.Expr) IScalabilityLatencyResultDo {
	return s.withDO(s.DO.Select(conds...))
}

func (s scalabilityLatencyResultDo) Where(conds ...gen.Condition) IScalabilityLatencyResultDo {
	return s.withDO(s.DO.Where(conds...))
}

func (s scalabilityLatencyResultDo) Order(conds ...field.Expr) IScalabilityLatencyResultDo {
	return s.withDO(s.DO.Order(conds...))
}

func (s scalabilityLatencyResultDo) Distinct(cols ...field.Expr) IScalabilityLatencyResultDo {
	return s.withDO(s.DO.Distinct(cols...))
}

func (s scalabilityLatencyResultDo) Omit(cols ...field.Expr) IScalabilityLatencyResultDo {
	return s.withDO(s.DO.Omit(cols...))
}

func (s scalabilityLatencyResultDo) Join(table schema.Tabler, on ...field.Expr) IScalabilityLatencyResultDo {
	return s.withDO(s.DO.Join(table, on...))
}

func (s scalabilityLatencyResultDo) LeftJoin(table schema.Tabler, on ...field.Expr) IScalabilityLatencyResultDo {
	return s.withDO(s.DO.LeftJoin(table, on...))
}

func (s scalabilityLatencyResultDo) RightJoin(table schema.Tabler, on ...field.Expr) IScalabilityLatencyResultDo {
	return s.withDO(s.DO.RightJoin(table, on...))
}

func (s scalabilityLatencyResultDo) Group(cols ...field.Expr) IScalabilityLatencyResultDo {
	return s.withDO(s.DO.Group(cols...))
}

func (s scalabilityLatencyResultDo) Having(conds ...gen.Condition) IScalabilityLatencyResultDo {
	return s.withDO(s.DO.Having(conds...))
}

func (s scalabilityLatencyResultDo) Limit(limit int) IScalabilityLatencyResultDo {
	return s.withDO(s.DO.Limit(limit))
}

func (s scalabilityLatencyResultDo) Offset(offset int) IScalabilityLatencyResultDo {
	return s.withDO(s.DO.Offset(offset))
}

func (s scalabilityLatencyResultDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IScalabilityLatencyResultDo {
	return s.withDO(s.DO.Scopes(funcs...))
}

func (s scalabilityLatencyResultDo) Unscoped() IScalabilityLatencyResultDo {
	return s.withDO(s.DO.Unscoped())
}

func (s scalabilityLatencyResultDo) Create(values ...*model.ScalabilityLatencyResult) error {
	if len(values) == 0 {
		return nil
	}
	return s.DO.Create(values)
}

func (s scalabilityLatencyResultDo) CreateInBatches(values []*model.ScalabilityLatencyResult, batchSize int) error {
	return s.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (s scalabilityLatencyResultDo) Save(values ...*model.ScalabilityLatencyResult) error {
	if len(values) == 0 {
		return nil
	}
	return s.DO.Save(values)
}

func (s scalabilityLatencyResultDo) First() (*model.ScalabilityLatencyResult, error) {
	if result, err := s.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.ScalabilityLatencyResult), nil
	}
}

func (s scalabilityLatencyResultDo) Take() (*model.ScalabilityLatencyResult, error) {
	if result, err := s.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.ScalabilityLatencyResult), nil
	}
}

func (s scalabilityLatencyResultDo) Last() (*model.ScalabilityLatencyResult, error) {
	if result, err := s.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.ScalabilityLatencyResult), nil
	}
}

func (s scalabilityLatencyResultDo) Find() ([]*model.ScalabilityLatencyResult, error) {
	result, err := s.DO.Find()
	return result.([]*model.ScalabilityLatencyResult), err
}

func (s scalabilityLatencyResultDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.ScalabilityLatencyResult, err error) {
	buf := make([]*model.ScalabilityLatencyResult, 0, batchSize)
	err = s.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (s scalabilityLatencyResultDo) FindInBatches(result *[]*model.ScalabilityLatencyResult, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return s.DO.FindInBatches(result, batchSize, fc)
}

func (s scalabilityLatencyResultDo) Attrs(attrs ...field.AssignExpr) IScalabilityLatencyResultDo {
	return s.withDO(s.DO.Attrs(attrs...))
}

func (s scalabilityLatencyResultDo) Assign(attrs ...field.AssignExpr) IScalabilityLatencyResultDo {
	return s.withDO(s.DO.Assign(attrs...))
}

func (s scalabilityLatencyResultDo) Joins(fields ...field.RelationField) IScalabilityLatencyResultDo {
	for _, _f := range fields {
		s = *s.withDO(s.DO.Joins(_f))
	}
	return &s
}

func (s scalabilityLatencyResultDo) Preload(fields ...field.RelationField) IScalabilityLatencyResultDo {
	for _, _f := range fields {
		s = *s.withDO(s.DO.Preload(_f))
	}
	return &s
}

func (s scalabilityLatencyResultDo) FirstOrInit() (*model.ScalabilityLatencyResult, error) {
	if result, err := s.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.ScalabilityLatencyResult), nil
	}
}

func (s scalabilityLatencyResultDo) FirstOrCreate() (*model.ScalabilityLatencyResult, error) {
	if result, err := s.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.ScalabilityLatencyResult), nil
	}
}

func (s scalabilityLatencyResultDo) FindByPage(offset int, limit int) (result []*model.ScalabilityLatencyResult, count int64, err error) {
	result, err = s.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = s.Offset(-1).Limit(-1).Count()
	return
}

func (s scalabilityLatencyResultDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = s.Count()
	if err != nil {
		return
	}

	err = s.Offset(offset).Limit(limit).Scan(result)
	return
}

func (s scalabilityLatencyResultDo) Scan(result interface{}) (err error) {
	return s.DO.Scan(result)
}

func (s scalabilityLatencyResultDo) Delete(models ...*model.ScalabilityLatencyResult) (result gen.ResultInfo, err error) {
	return s.DO.Delete(models)
}

func (s *scalabilityLatencyResultDo) withDO(do gen.Dao) *scalabilityLatencyResultDo {
	s.DO = *do.(*gen.DO)
	return s
}
