// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"CN-EU-FSIMS/internal/app/models/pasture"
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"
)

func newFarmDisRecord(db *gorm.DB, opts ...gen.DOOption) farmDisRecord {
	_farmDisRecord := farmDisRecord{}

	_farmDisRecord.farmDisRecordDo.UseDB(db, opts...)
	_farmDisRecord.farmDisRecordDo.UseModel(&pasture.FarmDisRecord{})

	tableName := _farmDisRecord.farmDisRecordDo.TableName()
	_farmDisRecord.ALL = field.NewAsterisk(tableName)
	_farmDisRecord.ID = field.NewUint(tableName, "id")
	_farmDisRecord.CreatedAt = field.NewTime(tableName, "created_at")
	_farmDisRecord.UpdatedAt = field.NewTime(tableName, "updated_at")
	_farmDisRecord.DeletedAt = field.NewField(tableName, "deleted_at")
	_farmDisRecord.FarmEnvironmentID = field.NewUint(tableName, "farm_environment_id")
	_farmDisRecord.FarmDisRecord1 = field.NewString(tableName, "farm_dis_record1")
	_farmDisRecord.FarmDisRecord2 = field.NewString(tableName, "farm_dis_record2")
	_farmDisRecord.FarmDisRecord3 = field.NewString(tableName, "farm_dis_record3")

	_farmDisRecord.fillFieldMap()

	return _farmDisRecord
}

type farmDisRecord struct {
	farmDisRecordDo farmDisRecordDo

	ALL               field.Asterisk
	ID                field.Uint
	CreatedAt         field.Time
	UpdatedAt         field.Time
	DeletedAt         field.Field
	FarmEnvironmentID field.Uint
	FarmDisRecord1    field.String
	FarmDisRecord2    field.String
	FarmDisRecord3    field.String

	fieldMap map[string]field.Expr
}

func (f farmDisRecord) Table(newTableName string) *farmDisRecord {
	f.farmDisRecordDo.UseTable(newTableName)
	return f.updateTableName(newTableName)
}

func (f farmDisRecord) As(alias string) *farmDisRecord {
	f.farmDisRecordDo.DO = *(f.farmDisRecordDo.As(alias).(*gen.DO))
	return f.updateTableName(alias)
}

func (f *farmDisRecord) updateTableName(table string) *farmDisRecord {
	f.ALL = field.NewAsterisk(table)
	f.ID = field.NewUint(table, "id")
	f.CreatedAt = field.NewTime(table, "created_at")
	f.UpdatedAt = field.NewTime(table, "updated_at")
	f.DeletedAt = field.NewField(table, "deleted_at")
	f.FarmEnvironmentID = field.NewUint(table, "farm_environment_id")
	f.FarmDisRecord1 = field.NewString(table, "farm_dis_record1")
	f.FarmDisRecord2 = field.NewString(table, "farm_dis_record2")
	f.FarmDisRecord3 = field.NewString(table, "farm_dis_record3")

	f.fillFieldMap()

	return f
}

func (f *farmDisRecord) WithContext(ctx context.Context) IFarmDisRecordDo {
	return f.farmDisRecordDo.WithContext(ctx)
}

func (f farmDisRecord) TableName() string { return f.farmDisRecordDo.TableName() }

func (f farmDisRecord) Alias() string { return f.farmDisRecordDo.Alias() }

func (f farmDisRecord) Columns(cols ...field.Expr) gen.Columns {
	return f.farmDisRecordDo.Columns(cols...)
}

func (f *farmDisRecord) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := f.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (f *farmDisRecord) fillFieldMap() {
	f.fieldMap = make(map[string]field.Expr, 8)
	f.fieldMap["id"] = f.ID
	f.fieldMap["created_at"] = f.CreatedAt
	f.fieldMap["updated_at"] = f.UpdatedAt
	f.fieldMap["deleted_at"] = f.DeletedAt
	f.fieldMap["farm_environment_id"] = f.FarmEnvironmentID
	f.fieldMap["farm_dis_record1"] = f.FarmDisRecord1
	f.fieldMap["farm_dis_record2"] = f.FarmDisRecord2
	f.fieldMap["farm_dis_record3"] = f.FarmDisRecord3
}

func (f farmDisRecord) clone(db *gorm.DB) farmDisRecord {
	f.farmDisRecordDo.ReplaceConnPool(db.Statement.ConnPool)
	return f
}

func (f farmDisRecord) replaceDB(db *gorm.DB) farmDisRecord {
	f.farmDisRecordDo.ReplaceDB(db)
	return f
}

type farmDisRecordDo struct{ gen.DO }

type IFarmDisRecordDo interface {
	gen.SubQuery
	Debug() IFarmDisRecordDo
	WithContext(ctx context.Context) IFarmDisRecordDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IFarmDisRecordDo
	WriteDB() IFarmDisRecordDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IFarmDisRecordDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IFarmDisRecordDo
	Not(conds ...gen.Condition) IFarmDisRecordDo
	Or(conds ...gen.Condition) IFarmDisRecordDo
	Select(conds ...field.Expr) IFarmDisRecordDo
	Where(conds ...gen.Condition) IFarmDisRecordDo
	Order(conds ...field.Expr) IFarmDisRecordDo
	Distinct(cols ...field.Expr) IFarmDisRecordDo
	Omit(cols ...field.Expr) IFarmDisRecordDo
	Join(table schema.Tabler, on ...field.Expr) IFarmDisRecordDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IFarmDisRecordDo
	RightJoin(table schema.Tabler, on ...field.Expr) IFarmDisRecordDo
	Group(cols ...field.Expr) IFarmDisRecordDo
	Having(conds ...gen.Condition) IFarmDisRecordDo
	Limit(limit int) IFarmDisRecordDo
	Offset(offset int) IFarmDisRecordDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IFarmDisRecordDo
	Unscoped() IFarmDisRecordDo
	Create(values ...*pasture.FarmDisRecord) error
	CreateInBatches(values []*pasture.FarmDisRecord, batchSize int) error
	Save(values ...*pasture.FarmDisRecord) error
	First() (*pasture.FarmDisRecord, error)
	Take() (*pasture.FarmDisRecord, error)
	Last() (*pasture.FarmDisRecord, error)
	Find() ([]*pasture.FarmDisRecord, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*pasture.FarmDisRecord, err error)
	FindInBatches(result *[]*pasture.FarmDisRecord, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*pasture.FarmDisRecord) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IFarmDisRecordDo
	Assign(attrs ...field.AssignExpr) IFarmDisRecordDo
	Joins(fields ...field.RelationField) IFarmDisRecordDo
	Preload(fields ...field.RelationField) IFarmDisRecordDo
	FirstOrInit() (*pasture.FarmDisRecord, error)
	FirstOrCreate() (*pasture.FarmDisRecord, error)
	FindByPage(offset int, limit int) (result []*pasture.FarmDisRecord, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IFarmDisRecordDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (f farmDisRecordDo) Debug() IFarmDisRecordDo {
	return f.withDO(f.DO.Debug())
}

func (f farmDisRecordDo) WithContext(ctx context.Context) IFarmDisRecordDo {
	return f.withDO(f.DO.WithContext(ctx))
}

func (f farmDisRecordDo) ReadDB() IFarmDisRecordDo {
	return f.Clauses(dbresolver.Read)
}

func (f farmDisRecordDo) WriteDB() IFarmDisRecordDo {
	return f.Clauses(dbresolver.Write)
}

func (f farmDisRecordDo) Session(config *gorm.Session) IFarmDisRecordDo {
	return f.withDO(f.DO.Session(config))
}

func (f farmDisRecordDo) Clauses(conds ...clause.Expression) IFarmDisRecordDo {
	return f.withDO(f.DO.Clauses(conds...))
}

func (f farmDisRecordDo) Returning(value interface{}, columns ...string) IFarmDisRecordDo {
	return f.withDO(f.DO.Returning(value, columns...))
}

func (f farmDisRecordDo) Not(conds ...gen.Condition) IFarmDisRecordDo {
	return f.withDO(f.DO.Not(conds...))
}

func (f farmDisRecordDo) Or(conds ...gen.Condition) IFarmDisRecordDo {
	return f.withDO(f.DO.Or(conds...))
}

func (f farmDisRecordDo) Select(conds ...field.Expr) IFarmDisRecordDo {
	return f.withDO(f.DO.Select(conds...))
}

func (f farmDisRecordDo) Where(conds ...gen.Condition) IFarmDisRecordDo {
	return f.withDO(f.DO.Where(conds...))
}

func (f farmDisRecordDo) Order(conds ...field.Expr) IFarmDisRecordDo {
	return f.withDO(f.DO.Order(conds...))
}

func (f farmDisRecordDo) Distinct(cols ...field.Expr) IFarmDisRecordDo {
	return f.withDO(f.DO.Distinct(cols...))
}

func (f farmDisRecordDo) Omit(cols ...field.Expr) IFarmDisRecordDo {
	return f.withDO(f.DO.Omit(cols...))
}

func (f farmDisRecordDo) Join(table schema.Tabler, on ...field.Expr) IFarmDisRecordDo {
	return f.withDO(f.DO.Join(table, on...))
}

func (f farmDisRecordDo) LeftJoin(table schema.Tabler, on ...field.Expr) IFarmDisRecordDo {
	return f.withDO(f.DO.LeftJoin(table, on...))
}

func (f farmDisRecordDo) RightJoin(table schema.Tabler, on ...field.Expr) IFarmDisRecordDo {
	return f.withDO(f.DO.RightJoin(table, on...))
}

func (f farmDisRecordDo) Group(cols ...field.Expr) IFarmDisRecordDo {
	return f.withDO(f.DO.Group(cols...))
}

func (f farmDisRecordDo) Having(conds ...gen.Condition) IFarmDisRecordDo {
	return f.withDO(f.DO.Having(conds...))
}

func (f farmDisRecordDo) Limit(limit int) IFarmDisRecordDo {
	return f.withDO(f.DO.Limit(limit))
}

func (f farmDisRecordDo) Offset(offset int) IFarmDisRecordDo {
	return f.withDO(f.DO.Offset(offset))
}

func (f farmDisRecordDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IFarmDisRecordDo {
	return f.withDO(f.DO.Scopes(funcs...))
}

func (f farmDisRecordDo) Unscoped() IFarmDisRecordDo {
	return f.withDO(f.DO.Unscoped())
}

func (f farmDisRecordDo) Create(values ...*pasture.FarmDisRecord) error {
	if len(values) == 0 {
		return nil
	}
	return f.DO.Create(values)
}

func (f farmDisRecordDo) CreateInBatches(values []*pasture.FarmDisRecord, batchSize int) error {
	return f.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (f farmDisRecordDo) Save(values ...*pasture.FarmDisRecord) error {
	if len(values) == 0 {
		return nil
	}
	return f.DO.Save(values)
}

func (f farmDisRecordDo) First() (*pasture.FarmDisRecord, error) {
	if result, err := f.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*pasture.FarmDisRecord), nil
	}
}

func (f farmDisRecordDo) Take() (*pasture.FarmDisRecord, error) {
	if result, err := f.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*pasture.FarmDisRecord), nil
	}
}

func (f farmDisRecordDo) Last() (*pasture.FarmDisRecord, error) {
	if result, err := f.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*pasture.FarmDisRecord), nil
	}
}

func (f farmDisRecordDo) Find() ([]*pasture.FarmDisRecord, error) {
	result, err := f.DO.Find()
	return result.([]*pasture.FarmDisRecord), err
}

func (f farmDisRecordDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*pasture.FarmDisRecord, err error) {
	buf := make([]*pasture.FarmDisRecord, 0, batchSize)
	err = f.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (f farmDisRecordDo) FindInBatches(result *[]*pasture.FarmDisRecord, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return f.DO.FindInBatches(result, batchSize, fc)
}

func (f farmDisRecordDo) Attrs(attrs ...field.AssignExpr) IFarmDisRecordDo {
	return f.withDO(f.DO.Attrs(attrs...))
}

func (f farmDisRecordDo) Assign(attrs ...field.AssignExpr) IFarmDisRecordDo {
	return f.withDO(f.DO.Assign(attrs...))
}

func (f farmDisRecordDo) Joins(fields ...field.RelationField) IFarmDisRecordDo {
	for _, _f := range fields {
		f = *f.withDO(f.DO.Joins(_f))
	}
	return &f
}

func (f farmDisRecordDo) Preload(fields ...field.RelationField) IFarmDisRecordDo {
	for _, _f := range fields {
		f = *f.withDO(f.DO.Preload(_f))
	}
	return &f
}

func (f farmDisRecordDo) FirstOrInit() (*pasture.FarmDisRecord, error) {
	if result, err := f.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*pasture.FarmDisRecord), nil
	}
}

func (f farmDisRecordDo) FirstOrCreate() (*pasture.FarmDisRecord, error) {
	if result, err := f.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*pasture.FarmDisRecord), nil
	}
}

func (f farmDisRecordDo) FindByPage(offset int, limit int) (result []*pasture.FarmDisRecord, count int64, err error) {
	result, err = f.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = f.Offset(-1).Limit(-1).Count()
	return
}

func (f farmDisRecordDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = f.Count()
	if err != nil {
		return
	}

	err = f.Offset(offset).Limit(limit).Scan(result)
	return
}

func (f farmDisRecordDo) Scan(result interface{}) (err error) {
	return f.DO.Scan(result)
}

func (f farmDisRecordDo) Delete(models ...*pasture.FarmDisRecord) (result gen.ResultInfo, err error) {
	return f.DO.Delete(models)
}

func (f *farmDisRecordDo) withDO(do gen.Dao) *farmDisRecordDo {
	f.DO = *do.(*gen.DO)
	return f
}
