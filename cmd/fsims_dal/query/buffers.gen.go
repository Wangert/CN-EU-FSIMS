// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"CN-EU-FSIMS/internal/app/models/pasture"
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"
)

func newBuffer(db *gorm.DB, opts ...gen.DOOption) buffer {
	_buffer := buffer{}

	_buffer.bufferDo.UseDB(db, opts...)
	_buffer.bufferDo.UseModel(&pasture.Buffer{})

	tableName := _buffer.bufferDo.TableName()
	_buffer.ALL = field.NewAsterisk(tableName)
	_buffer.ID = field.NewUint(tableName, "id")
	_buffer.CreatedAt = field.NewTime(tableName, "created_at")
	_buffer.UpdatedAt = field.NewTime(tableName, "updated_at")
	_buffer.DeletedAt = field.NewField(tableName, "deleted_at")
	_buffer.FarmEnvironmentID = field.NewUint(tableName, "farm_environment_id")
	_buffer.Buffer1 = field.NewFloat32(tableName, "buffer1")
	_buffer.Buffer2 = field.NewFloat32(tableName, "buffer2")
	_buffer.Buffer3 = field.NewFloat32(tableName, "buffer3")
	_buffer.Buffer4 = field.NewFloat32(tableName, "buffer4")
	_buffer.Buffer5 = field.NewFloat32(tableName, "buffer5")
	_buffer.Buffer6 = field.NewFloat32(tableName, "buffer6")
	_buffer.Buffer7 = field.NewFloat32(tableName, "buffer7")
	_buffer.Buffer8 = field.NewFloat32(tableName, "buffer8")
	_buffer.Buffer9 = field.NewFloat32(tableName, "buffer9")
	_buffer.Buffer10 = field.NewFloat32(tableName, "buffer10")
	_buffer.Buffer11 = field.NewFloat32(tableName, "buffer11")
	_buffer.Buffer12 = field.NewFloat32(tableName, "buffer12")

	_buffer.fillFieldMap()

	return _buffer
}

type buffer struct {
	bufferDo bufferDo

	ALL               field.Asterisk
	ID                field.Uint
	CreatedAt         field.Time
	UpdatedAt         field.Time
	DeletedAt         field.Field
	FarmEnvironmentID field.Uint
	Buffer1           field.Float32
	Buffer2           field.Float32
	Buffer3           field.Float32
	Buffer4           field.Float32
	Buffer5           field.Float32
	Buffer6           field.Float32
	Buffer7           field.Float32
	Buffer8           field.Float32
	Buffer9           field.Float32
	Buffer10          field.Float32
	Buffer11          field.Float32
	Buffer12          field.Float32

	fieldMap map[string]field.Expr
}

func (b buffer) Table(newTableName string) *buffer {
	b.bufferDo.UseTable(newTableName)
	return b.updateTableName(newTableName)
}

func (b buffer) As(alias string) *buffer {
	b.bufferDo.DO = *(b.bufferDo.As(alias).(*gen.DO))
	return b.updateTableName(alias)
}

func (b *buffer) updateTableName(table string) *buffer {
	b.ALL = field.NewAsterisk(table)
	b.ID = field.NewUint(table, "id")
	b.CreatedAt = field.NewTime(table, "created_at")
	b.UpdatedAt = field.NewTime(table, "updated_at")
	b.DeletedAt = field.NewField(table, "deleted_at")
	b.FarmEnvironmentID = field.NewUint(table, "farm_environment_id")
	b.Buffer1 = field.NewFloat32(table, "buffer1")
	b.Buffer2 = field.NewFloat32(table, "buffer2")
	b.Buffer3 = field.NewFloat32(table, "buffer3")
	b.Buffer4 = field.NewFloat32(table, "buffer4")
	b.Buffer5 = field.NewFloat32(table, "buffer5")
	b.Buffer6 = field.NewFloat32(table, "buffer6")
	b.Buffer7 = field.NewFloat32(table, "buffer7")
	b.Buffer8 = field.NewFloat32(table, "buffer8")
	b.Buffer9 = field.NewFloat32(table, "buffer9")
	b.Buffer10 = field.NewFloat32(table, "buffer10")
	b.Buffer11 = field.NewFloat32(table, "buffer11")
	b.Buffer12 = field.NewFloat32(table, "buffer12")

	b.fillFieldMap()

	return b
}

func (b *buffer) WithContext(ctx context.Context) IBufferDo { return b.bufferDo.WithContext(ctx) }

func (b buffer) TableName() string { return b.bufferDo.TableName() }

func (b buffer) Alias() string { return b.bufferDo.Alias() }

func (b buffer) Columns(cols ...field.Expr) gen.Columns { return b.bufferDo.Columns(cols...) }

func (b *buffer) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := b.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (b *buffer) fillFieldMap() {
	b.fieldMap = make(map[string]field.Expr, 17)
	b.fieldMap["id"] = b.ID
	b.fieldMap["created_at"] = b.CreatedAt
	b.fieldMap["updated_at"] = b.UpdatedAt
	b.fieldMap["deleted_at"] = b.DeletedAt
	b.fieldMap["farm_environment_id"] = b.FarmEnvironmentID
	b.fieldMap["buffer1"] = b.Buffer1
	b.fieldMap["buffer2"] = b.Buffer2
	b.fieldMap["buffer3"] = b.Buffer3
	b.fieldMap["buffer4"] = b.Buffer4
	b.fieldMap["buffer5"] = b.Buffer5
	b.fieldMap["buffer6"] = b.Buffer6
	b.fieldMap["buffer7"] = b.Buffer7
	b.fieldMap["buffer8"] = b.Buffer8
	b.fieldMap["buffer9"] = b.Buffer9
	b.fieldMap["buffer10"] = b.Buffer10
	b.fieldMap["buffer11"] = b.Buffer11
	b.fieldMap["buffer12"] = b.Buffer12
}

func (b buffer) clone(db *gorm.DB) buffer {
	b.bufferDo.ReplaceConnPool(db.Statement.ConnPool)
	return b
}

func (b buffer) replaceDB(db *gorm.DB) buffer {
	b.bufferDo.ReplaceDB(db)
	return b
}

type bufferDo struct{ gen.DO }

type IBufferDo interface {
	gen.SubQuery
	Debug() IBufferDo
	WithContext(ctx context.Context) IBufferDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IBufferDo
	WriteDB() IBufferDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IBufferDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IBufferDo
	Not(conds ...gen.Condition) IBufferDo
	Or(conds ...gen.Condition) IBufferDo
	Select(conds ...field.Expr) IBufferDo
	Where(conds ...gen.Condition) IBufferDo
	Order(conds ...field.Expr) IBufferDo
	Distinct(cols ...field.Expr) IBufferDo
	Omit(cols ...field.Expr) IBufferDo
	Join(table schema.Tabler, on ...field.Expr) IBufferDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IBufferDo
	RightJoin(table schema.Tabler, on ...field.Expr) IBufferDo
	Group(cols ...field.Expr) IBufferDo
	Having(conds ...gen.Condition) IBufferDo
	Limit(limit int) IBufferDo
	Offset(offset int) IBufferDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IBufferDo
	Unscoped() IBufferDo
	Create(values ...*pasture.Buffer) error
	CreateInBatches(values []*pasture.Buffer, batchSize int) error
	Save(values ...*pasture.Buffer) error
	First() (*pasture.Buffer, error)
	Take() (*pasture.Buffer, error)
	Last() (*pasture.Buffer, error)
	Find() ([]*pasture.Buffer, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*pasture.Buffer, err error)
	FindInBatches(result *[]*pasture.Buffer, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*pasture.Buffer) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IBufferDo
	Assign(attrs ...field.AssignExpr) IBufferDo
	Joins(fields ...field.RelationField) IBufferDo
	Preload(fields ...field.RelationField) IBufferDo
	FirstOrInit() (*pasture.Buffer, error)
	FirstOrCreate() (*pasture.Buffer, error)
	FindByPage(offset int, limit int) (result []*pasture.Buffer, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IBufferDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (b bufferDo) Debug() IBufferDo {
	return b.withDO(b.DO.Debug())
}

func (b bufferDo) WithContext(ctx context.Context) IBufferDo {
	return b.withDO(b.DO.WithContext(ctx))
}

func (b bufferDo) ReadDB() IBufferDo {
	return b.Clauses(dbresolver.Read)
}

func (b bufferDo) WriteDB() IBufferDo {
	return b.Clauses(dbresolver.Write)
}

func (b bufferDo) Session(config *gorm.Session) IBufferDo {
	return b.withDO(b.DO.Session(config))
}

func (b bufferDo) Clauses(conds ...clause.Expression) IBufferDo {
	return b.withDO(b.DO.Clauses(conds...))
}

func (b bufferDo) Returning(value interface{}, columns ...string) IBufferDo {
	return b.withDO(b.DO.Returning(value, columns...))
}

func (b bufferDo) Not(conds ...gen.Condition) IBufferDo {
	return b.withDO(b.DO.Not(conds...))
}

func (b bufferDo) Or(conds ...gen.Condition) IBufferDo {
	return b.withDO(b.DO.Or(conds...))
}

func (b bufferDo) Select(conds ...field.Expr) IBufferDo {
	return b.withDO(b.DO.Select(conds...))
}

func (b bufferDo) Where(conds ...gen.Condition) IBufferDo {
	return b.withDO(b.DO.Where(conds...))
}

func (b bufferDo) Order(conds ...field.Expr) IBufferDo {
	return b.withDO(b.DO.Order(conds...))
}

func (b bufferDo) Distinct(cols ...field.Expr) IBufferDo {
	return b.withDO(b.DO.Distinct(cols...))
}

func (b bufferDo) Omit(cols ...field.Expr) IBufferDo {
	return b.withDO(b.DO.Omit(cols...))
}

func (b bufferDo) Join(table schema.Tabler, on ...field.Expr) IBufferDo {
	return b.withDO(b.DO.Join(table, on...))
}

func (b bufferDo) LeftJoin(table schema.Tabler, on ...field.Expr) IBufferDo {
	return b.withDO(b.DO.LeftJoin(table, on...))
}

func (b bufferDo) RightJoin(table schema.Tabler, on ...field.Expr) IBufferDo {
	return b.withDO(b.DO.RightJoin(table, on...))
}

func (b bufferDo) Group(cols ...field.Expr) IBufferDo {
	return b.withDO(b.DO.Group(cols...))
}

func (b bufferDo) Having(conds ...gen.Condition) IBufferDo {
	return b.withDO(b.DO.Having(conds...))
}

func (b bufferDo) Limit(limit int) IBufferDo {
	return b.withDO(b.DO.Limit(limit))
}

func (b bufferDo) Offset(offset int) IBufferDo {
	return b.withDO(b.DO.Offset(offset))
}

func (b bufferDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IBufferDo {
	return b.withDO(b.DO.Scopes(funcs...))
}

func (b bufferDo) Unscoped() IBufferDo {
	return b.withDO(b.DO.Unscoped())
}

func (b bufferDo) Create(values ...*pasture.Buffer) error {
	if len(values) == 0 {
		return nil
	}
	return b.DO.Create(values)
}

func (b bufferDo) CreateInBatches(values []*pasture.Buffer, batchSize int) error {
	return b.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (b bufferDo) Save(values ...*pasture.Buffer) error {
	if len(values) == 0 {
		return nil
	}
	return b.DO.Save(values)
}

func (b bufferDo) First() (*pasture.Buffer, error) {
	if result, err := b.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*pasture.Buffer), nil
	}
}

func (b bufferDo) Take() (*pasture.Buffer, error) {
	if result, err := b.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*pasture.Buffer), nil
	}
}

func (b bufferDo) Last() (*pasture.Buffer, error) {
	if result, err := b.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*pasture.Buffer), nil
	}
}

func (b bufferDo) Find() ([]*pasture.Buffer, error) {
	result, err := b.DO.Find()
	return result.([]*pasture.Buffer), err
}

func (b bufferDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*pasture.Buffer, err error) {
	buf := make([]*pasture.Buffer, 0, batchSize)
	err = b.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (b bufferDo) FindInBatches(result *[]*pasture.Buffer, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return b.DO.FindInBatches(result, batchSize, fc)
}

func (b bufferDo) Attrs(attrs ...field.AssignExpr) IBufferDo {
	return b.withDO(b.DO.Attrs(attrs...))
}

func (b bufferDo) Assign(attrs ...field.AssignExpr) IBufferDo {
	return b.withDO(b.DO.Assign(attrs...))
}

func (b bufferDo) Joins(fields ...field.RelationField) IBufferDo {
	for _, _f := range fields {
		b = *b.withDO(b.DO.Joins(_f))
	}
	return &b
}

func (b bufferDo) Preload(fields ...field.RelationField) IBufferDo {
	for _, _f := range fields {
		b = *b.withDO(b.DO.Preload(_f))
	}
	return &b
}

func (b bufferDo) FirstOrInit() (*pasture.Buffer, error) {
	if result, err := b.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*pasture.Buffer), nil
	}
}

func (b bufferDo) FirstOrCreate() (*pasture.Buffer, error) {
	if result, err := b.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*pasture.Buffer), nil
	}
}

func (b bufferDo) FindByPage(offset int, limit int) (result []*pasture.Buffer, count int64, err error) {
	result, err = b.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = b.Offset(-1).Limit(-1).Count()
	return
}

func (b bufferDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = b.Count()
	if err != nil {
		return
	}

	err = b.Offset(offset).Limit(limit).Scan(result)
	return
}

func (b bufferDo) Scan(result interface{}) (err error) {
	return b.DO.Scan(result)
}

func (b bufferDo) Delete(models ...*pasture.Buffer) (result gen.ResultInfo, err error) {
	return b.DO.Delete(models)
}

func (b *bufferDo) withDO(do gen.Dao) *bufferDo {
	b.DO = *do.(*gen.DO)
	return b
}
