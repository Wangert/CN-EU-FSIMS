// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"CN-EU-FSIMS/internal/app/models/pasture"
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"
)

func newCattleFarm(db *gorm.DB, opts ...gen.DOOption) cattleFarm {
	_cattleFarm := cattleFarm{}

	_cattleFarm.cattleFarmDo.UseDB(db, opts...)
	_cattleFarm.cattleFarmDo.UseModel(&pasture.CattleFarm{})

	tableName := _cattleFarm.cattleFarmDo.TableName()
	_cattleFarm.ALL = field.NewAsterisk(tableName)
	_cattleFarm.ID = field.NewUint(tableName, "id")
	_cattleFarm.CreatedAt = field.NewTime(tableName, "created_at")
	_cattleFarm.UpdatedAt = field.NewTime(tableName, "updated_at")
	_cattleFarm.DeletedAt = field.NewField(tableName, "deleted_at")
	_cattleFarm.FarmEnvironmentID = field.NewUint(tableName, "farm_environment_id")
	_cattleFarm.CattleFarm1 = field.NewFloat32(tableName, "cattle_farm1")
	_cattleFarm.CattleFarm2 = field.NewFloat32(tableName, "cattle_farm2")
	_cattleFarm.CattleFarm3 = field.NewFloat32(tableName, "cattle_farm3")
	_cattleFarm.CattleFarm4 = field.NewFloat32(tableName, "cattle_farm4")
	_cattleFarm.CattleFarm5 = field.NewFloat32(tableName, "cattle_farm5")
	_cattleFarm.CattleFarm6 = field.NewFloat32(tableName, "cattle_farm6")
	_cattleFarm.CattleFarm7 = field.NewFloat32(tableName, "cattle_farm7")
	_cattleFarm.CattleFarm8 = field.NewFloat32(tableName, "cattle_farm8")
	_cattleFarm.CattleFarm9 = field.NewFloat32(tableName, "cattle_farm9")
	_cattleFarm.CattleFarm10 = field.NewFloat32(tableName, "cattle_farm10")
	_cattleFarm.CattleFarm11 = field.NewFloat32(tableName, "cattle_farm11")
	_cattleFarm.CattleFarm12 = field.NewFloat32(tableName, "cattle_farm12")

	_cattleFarm.fillFieldMap()

	return _cattleFarm
}

type cattleFarm struct {
	cattleFarmDo cattleFarmDo

	ALL               field.Asterisk
	ID                field.Uint
	CreatedAt         field.Time
	UpdatedAt         field.Time
	DeletedAt         field.Field
	FarmEnvironmentID field.Uint
	CattleFarm1       field.Float32
	CattleFarm2       field.Float32
	CattleFarm3       field.Float32
	CattleFarm4       field.Float32
	CattleFarm5       field.Float32
	CattleFarm6       field.Float32
	CattleFarm7       field.Float32
	CattleFarm8       field.Float32
	CattleFarm9       field.Float32
	CattleFarm10      field.Float32
	CattleFarm11      field.Float32
	CattleFarm12      field.Float32

	fieldMap map[string]field.Expr
}

func (c cattleFarm) Table(newTableName string) *cattleFarm {
	c.cattleFarmDo.UseTable(newTableName)
	return c.updateTableName(newTableName)
}

func (c cattleFarm) As(alias string) *cattleFarm {
	c.cattleFarmDo.DO = *(c.cattleFarmDo.As(alias).(*gen.DO))
	return c.updateTableName(alias)
}

func (c *cattleFarm) updateTableName(table string) *cattleFarm {
	c.ALL = field.NewAsterisk(table)
	c.ID = field.NewUint(table, "id")
	c.CreatedAt = field.NewTime(table, "created_at")
	c.UpdatedAt = field.NewTime(table, "updated_at")
	c.DeletedAt = field.NewField(table, "deleted_at")
	c.FarmEnvironmentID = field.NewUint(table, "farm_environment_id")
	c.CattleFarm1 = field.NewFloat32(table, "cattle_farm1")
	c.CattleFarm2 = field.NewFloat32(table, "cattle_farm2")
	c.CattleFarm3 = field.NewFloat32(table, "cattle_farm3")
	c.CattleFarm4 = field.NewFloat32(table, "cattle_farm4")
	c.CattleFarm5 = field.NewFloat32(table, "cattle_farm5")
	c.CattleFarm6 = field.NewFloat32(table, "cattle_farm6")
	c.CattleFarm7 = field.NewFloat32(table, "cattle_farm7")
	c.CattleFarm8 = field.NewFloat32(table, "cattle_farm8")
	c.CattleFarm9 = field.NewFloat32(table, "cattle_farm9")
	c.CattleFarm10 = field.NewFloat32(table, "cattle_farm10")
	c.CattleFarm11 = field.NewFloat32(table, "cattle_farm11")
	c.CattleFarm12 = field.NewFloat32(table, "cattle_farm12")

	c.fillFieldMap()

	return c
}

func (c *cattleFarm) WithContext(ctx context.Context) ICattleFarmDo {
	return c.cattleFarmDo.WithContext(ctx)
}

func (c cattleFarm) TableName() string { return c.cattleFarmDo.TableName() }

func (c cattleFarm) Alias() string { return c.cattleFarmDo.Alias() }

func (c cattleFarm) Columns(cols ...field.Expr) gen.Columns { return c.cattleFarmDo.Columns(cols...) }

func (c *cattleFarm) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := c.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (c *cattleFarm) fillFieldMap() {
	c.fieldMap = make(map[string]field.Expr, 17)
	c.fieldMap["id"] = c.ID
	c.fieldMap["created_at"] = c.CreatedAt
	c.fieldMap["updated_at"] = c.UpdatedAt
	c.fieldMap["deleted_at"] = c.DeletedAt
	c.fieldMap["farm_environment_id"] = c.FarmEnvironmentID
	c.fieldMap["cattle_farm1"] = c.CattleFarm1
	c.fieldMap["cattle_farm2"] = c.CattleFarm2
	c.fieldMap["cattle_farm3"] = c.CattleFarm3
	c.fieldMap["cattle_farm4"] = c.CattleFarm4
	c.fieldMap["cattle_farm5"] = c.CattleFarm5
	c.fieldMap["cattle_farm6"] = c.CattleFarm6
	c.fieldMap["cattle_farm7"] = c.CattleFarm7
	c.fieldMap["cattle_farm8"] = c.CattleFarm8
	c.fieldMap["cattle_farm9"] = c.CattleFarm9
	c.fieldMap["cattle_farm10"] = c.CattleFarm10
	c.fieldMap["cattle_farm11"] = c.CattleFarm11
	c.fieldMap["cattle_farm12"] = c.CattleFarm12
}

func (c cattleFarm) clone(db *gorm.DB) cattleFarm {
	c.cattleFarmDo.ReplaceConnPool(db.Statement.ConnPool)
	return c
}

func (c cattleFarm) replaceDB(db *gorm.DB) cattleFarm {
	c.cattleFarmDo.ReplaceDB(db)
	return c
}

type cattleFarmDo struct{ gen.DO }

type ICattleFarmDo interface {
	gen.SubQuery
	Debug() ICattleFarmDo
	WithContext(ctx context.Context) ICattleFarmDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() ICattleFarmDo
	WriteDB() ICattleFarmDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) ICattleFarmDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) ICattleFarmDo
	Not(conds ...gen.Condition) ICattleFarmDo
	Or(conds ...gen.Condition) ICattleFarmDo
	Select(conds ...field.Expr) ICattleFarmDo
	Where(conds ...gen.Condition) ICattleFarmDo
	Order(conds ...field.Expr) ICattleFarmDo
	Distinct(cols ...field.Expr) ICattleFarmDo
	Omit(cols ...field.Expr) ICattleFarmDo
	Join(table schema.Tabler, on ...field.Expr) ICattleFarmDo
	LeftJoin(table schema.Tabler, on ...field.Expr) ICattleFarmDo
	RightJoin(table schema.Tabler, on ...field.Expr) ICattleFarmDo
	Group(cols ...field.Expr) ICattleFarmDo
	Having(conds ...gen.Condition) ICattleFarmDo
	Limit(limit int) ICattleFarmDo
	Offset(offset int) ICattleFarmDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) ICattleFarmDo
	Unscoped() ICattleFarmDo
	Create(values ...*pasture.CattleFarm) error
	CreateInBatches(values []*pasture.CattleFarm, batchSize int) error
	Save(values ...*pasture.CattleFarm) error
	First() (*pasture.CattleFarm, error)
	Take() (*pasture.CattleFarm, error)
	Last() (*pasture.CattleFarm, error)
	Find() ([]*pasture.CattleFarm, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*pasture.CattleFarm, err error)
	FindInBatches(result *[]*pasture.CattleFarm, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*pasture.CattleFarm) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) ICattleFarmDo
	Assign(attrs ...field.AssignExpr) ICattleFarmDo
	Joins(fields ...field.RelationField) ICattleFarmDo
	Preload(fields ...field.RelationField) ICattleFarmDo
	FirstOrInit() (*pasture.CattleFarm, error)
	FirstOrCreate() (*pasture.CattleFarm, error)
	FindByPage(offset int, limit int) (result []*pasture.CattleFarm, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) ICattleFarmDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (c cattleFarmDo) Debug() ICattleFarmDo {
	return c.withDO(c.DO.Debug())
}

func (c cattleFarmDo) WithContext(ctx context.Context) ICattleFarmDo {
	return c.withDO(c.DO.WithContext(ctx))
}

func (c cattleFarmDo) ReadDB() ICattleFarmDo {
	return c.Clauses(dbresolver.Read)
}

func (c cattleFarmDo) WriteDB() ICattleFarmDo {
	return c.Clauses(dbresolver.Write)
}

func (c cattleFarmDo) Session(config *gorm.Session) ICattleFarmDo {
	return c.withDO(c.DO.Session(config))
}

func (c cattleFarmDo) Clauses(conds ...clause.Expression) ICattleFarmDo {
	return c.withDO(c.DO.Clauses(conds...))
}

func (c cattleFarmDo) Returning(value interface{}, columns ...string) ICattleFarmDo {
	return c.withDO(c.DO.Returning(value, columns...))
}

func (c cattleFarmDo) Not(conds ...gen.Condition) ICattleFarmDo {
	return c.withDO(c.DO.Not(conds...))
}

func (c cattleFarmDo) Or(conds ...gen.Condition) ICattleFarmDo {
	return c.withDO(c.DO.Or(conds...))
}

func (c cattleFarmDo) Select(conds ...field.Expr) ICattleFarmDo {
	return c.withDO(c.DO.Select(conds...))
}

func (c cattleFarmDo) Where(conds ...gen.Condition) ICattleFarmDo {
	return c.withDO(c.DO.Where(conds...))
}

func (c cattleFarmDo) Order(conds ...field.Expr) ICattleFarmDo {
	return c.withDO(c.DO.Order(conds...))
}

func (c cattleFarmDo) Distinct(cols ...field.Expr) ICattleFarmDo {
	return c.withDO(c.DO.Distinct(cols...))
}

func (c cattleFarmDo) Omit(cols ...field.Expr) ICattleFarmDo {
	return c.withDO(c.DO.Omit(cols...))
}

func (c cattleFarmDo) Join(table schema.Tabler, on ...field.Expr) ICattleFarmDo {
	return c.withDO(c.DO.Join(table, on...))
}

func (c cattleFarmDo) LeftJoin(table schema.Tabler, on ...field.Expr) ICattleFarmDo {
	return c.withDO(c.DO.LeftJoin(table, on...))
}

func (c cattleFarmDo) RightJoin(table schema.Tabler, on ...field.Expr) ICattleFarmDo {
	return c.withDO(c.DO.RightJoin(table, on...))
}

func (c cattleFarmDo) Group(cols ...field.Expr) ICattleFarmDo {
	return c.withDO(c.DO.Group(cols...))
}

func (c cattleFarmDo) Having(conds ...gen.Condition) ICattleFarmDo {
	return c.withDO(c.DO.Having(conds...))
}

func (c cattleFarmDo) Limit(limit int) ICattleFarmDo {
	return c.withDO(c.DO.Limit(limit))
}

func (c cattleFarmDo) Offset(offset int) ICattleFarmDo {
	return c.withDO(c.DO.Offset(offset))
}

func (c cattleFarmDo) Scopes(funcs ...func(gen.Dao) gen.Dao) ICattleFarmDo {
	return c.withDO(c.DO.Scopes(funcs...))
}

func (c cattleFarmDo) Unscoped() ICattleFarmDo {
	return c.withDO(c.DO.Unscoped())
}

func (c cattleFarmDo) Create(values ...*pasture.CattleFarm) error {
	if len(values) == 0 {
		return nil
	}
	return c.DO.Create(values)
}

func (c cattleFarmDo) CreateInBatches(values []*pasture.CattleFarm, batchSize int) error {
	return c.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (c cattleFarmDo) Save(values ...*pasture.CattleFarm) error {
	if len(values) == 0 {
		return nil
	}
	return c.DO.Save(values)
}

func (c cattleFarmDo) First() (*pasture.CattleFarm, error) {
	if result, err := c.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*pasture.CattleFarm), nil
	}
}

func (c cattleFarmDo) Take() (*pasture.CattleFarm, error) {
	if result, err := c.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*pasture.CattleFarm), nil
	}
}

func (c cattleFarmDo) Last() (*pasture.CattleFarm, error) {
	if result, err := c.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*pasture.CattleFarm), nil
	}
}

func (c cattleFarmDo) Find() ([]*pasture.CattleFarm, error) {
	result, err := c.DO.Find()
	return result.([]*pasture.CattleFarm), err
}

func (c cattleFarmDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*pasture.CattleFarm, err error) {
	buf := make([]*pasture.CattleFarm, 0, batchSize)
	err = c.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (c cattleFarmDo) FindInBatches(result *[]*pasture.CattleFarm, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return c.DO.FindInBatches(result, batchSize, fc)
}

func (c cattleFarmDo) Attrs(attrs ...field.AssignExpr) ICattleFarmDo {
	return c.withDO(c.DO.Attrs(attrs...))
}

func (c cattleFarmDo) Assign(attrs ...field.AssignExpr) ICattleFarmDo {
	return c.withDO(c.DO.Assign(attrs...))
}

func (c cattleFarmDo) Joins(fields ...field.RelationField) ICattleFarmDo {
	for _, _f := range fields {
		c = *c.withDO(c.DO.Joins(_f))
	}
	return &c
}

func (c cattleFarmDo) Preload(fields ...field.RelationField) ICattleFarmDo {
	for _, _f := range fields {
		c = *c.withDO(c.DO.Preload(_f))
	}
	return &c
}

func (c cattleFarmDo) FirstOrInit() (*pasture.CattleFarm, error) {
	if result, err := c.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*pasture.CattleFarm), nil
	}
}

func (c cattleFarmDo) FirstOrCreate() (*pasture.CattleFarm, error) {
	if result, err := c.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*pasture.CattleFarm), nil
	}
}

func (c cattleFarmDo) FindByPage(offset int, limit int) (result []*pasture.CattleFarm, count int64, err error) {
	result, err = c.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = c.Offset(-1).Limit(-1).Count()
	return
}

func (c cattleFarmDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = c.Count()
	if err != nil {
		return
	}

	err = c.Offset(offset).Limit(limit).Scan(result)
	return
}

func (c cattleFarmDo) Scan(result interface{}) (err error) {
	return c.DO.Scan(result)
}

func (c cattleFarmDo) Delete(models ...*pasture.CattleFarm) (result gen.ResultInfo, err error) {
	return c.DO.Delete(models)
}

func (c *cattleFarmDo) withDO(do gen.Dao) *cattleFarmDo {
	c.DO = *do.(*gen.DO)
	return c
}
