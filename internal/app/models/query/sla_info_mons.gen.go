// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"CN-EU-FSIMS/internal/app/models/slaughter"
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"
)

func newSlaInfoMon(db *gorm.DB, opts ...gen.DOOption) slaInfoMon {
	_slaInfoMon := slaInfoMon{}

	_slaInfoMon.slaInfoMonDo.UseDB(db, opts...)
	_slaInfoMon.slaInfoMonDo.UseModel(&slaughter.SlaInfoMon{})

	tableName := _slaInfoMon.slaInfoMonDo.TableName()
	_slaInfoMon.ALL = field.NewAsterisk(tableName)
	_slaInfoMon.ID = field.NewUint(tableName, "id")
	_slaInfoMon.CreatedAt = field.NewTime(tableName, "created_at")
	_slaInfoMon.UpdatedAt = field.NewTime(tableName, "updated_at")
	_slaInfoMon.DeletedAt = field.NewField(tableName, "deleted_at")
	_slaInfoMon.HouseNumber = field.NewString(tableName, "house_number")
	_slaInfoMon.TimeRecordAt = field.NewString(tableName, "time_record_at")
	_slaInfoMon.WeightMoni = field.NewFloat32(tableName, "weight_moni")
	_slaInfoMon.Stun = slaInfoMonHasOneStun{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("Stun", "slaughter.Stun"),
	}

	_slaInfoMon.BleedElectronic = slaInfoMonHasOneBleedElectronic{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("BleedElectronic", "slaughter.BleedElectronic"),
	}

	_slaInfoMon.AnalAfterSlaQuanCar = slaInfoMonHasOneAnalAfterSlaQuanCar{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("AnalAfterSlaQuanCar", "slaughter.AnalAfterSlaQuanCar"),
	}

	_slaInfoMon.PreSlaQuanPic = slaInfoMonHasOnePreSlaQuanPic{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("PreSlaQuanPic", "slaughter.PreSlaQuanPic"),
	}

	_slaInfoMon.WaterTempMoni = slaInfoMonHasOneWaterTempMoni{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("WaterTempMoni", "slaughter.WaterTempMoni"),
	}

	_slaInfoMon.AnalCutWeight = slaInfoMonHasOneAnalCutWeight{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("AnalCutWeight", "slaughter.AnalCutWeight"),
	}

	_slaInfoMon.TempHumMon = slaInfoMonHasOneTempHumMon{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("TempHumMon", "slaughter.TempHumMon"),
	}

	_slaInfoMon.FacDisMon = slaInfoMonHasOneFacDisMon{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("FacDisMon", "slaughter.FacDisMon"),
		SlaShop: struct {
			field.RelationField
			SlaShop8 struct {
				field.RelationField
			}
		}{
			RelationField: field.NewRelation("FacDisMon.SlaShop", "slaughter.SlaShop"),
			SlaShop8: struct {
				field.RelationField
			}{
				RelationField: field.NewRelation("FacDisMon.SlaShop.SlaShop8", "slaughter.DisRecord"),
			},
		},
		DivShop: struct {
			field.RelationField
			DivShop8 struct {
				field.RelationField
			}
		}{
			RelationField: field.NewRelation("FacDisMon.DivShop", "slaughter.DivShop"),
			DivShop8: struct {
				field.RelationField
			}{
				RelationField: field.NewRelation("FacDisMon.DivShop.DivShop8", "slaughter.DisRecord"),
			},
		},
		AcidShop: struct {
			field.RelationField
			AcidShop8 struct {
				field.RelationField
			}
		}{
			RelationField: field.NewRelation("FacDisMon.AcidShop", "slaughter.AcidShop"),
			AcidShop8: struct {
				field.RelationField
			}{
				RelationField: field.NewRelation("FacDisMon.AcidShop.AcidShop8", "slaughter.DisRecord"),
			},
		},
		FroShop: struct {
			field.RelationField
			FroShop8 struct {
				field.RelationField
			}
		}{
			RelationField: field.NewRelation("FacDisMon.FroShop", "slaughter.FroShop"),
			FroShop8: struct {
				field.RelationField
			}{
				RelationField: field.NewRelation("FacDisMon.FroShop.FroShop8", "slaughter.DisRecord"),
			},
		},
		PackShop: struct {
			field.RelationField
			PackShop8 struct {
				field.RelationField
			}
		}{
			RelationField: field.NewRelation("FacDisMon.PackShop", "slaughter.PackShop"),
			PackShop8: struct {
				field.RelationField
			}{
				RelationField: field.NewRelation("FacDisMon.PackShop.PackShop8", "slaughter.DisRecord"),
			},
		},
		StaUni: struct {
			field.RelationField
			StaUni8 struct {
				field.RelationField
			}
		}{
			RelationField: field.NewRelation("FacDisMon.StaUni", "slaughter.StaUni"),
			StaUni8: struct {
				field.RelationField
			}{
				RelationField: field.NewRelation("FacDisMon.StaUni.StaUni8", "slaughter.DisRecord"),
			},
		},
	}

	_slaInfoMon.SlaEnvLigRec = slaInfoMonHasOneSlaEnvLigRec{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("SlaEnvLigRec", "slaughter.SlaEnvLigRec"),
	}

	_slaInfoMon.ToNumGermMon = slaInfoMonHasOneToNumGermMon{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("ToNumGermMon", "slaughter.ToNumGermMon"),
	}

	_slaInfoMon.AirNumGermMon = slaInfoMonHasOneAirNumGermMon{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("AirNumGermMon", "slaughter.AirNumGermMon"),
	}

	_slaInfoMon.WaterQualityMon = slaInfoMonHasOneWaterQualityMon{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("WaterQualityMon", "slaughter.WaterQualityMon"),
		MicroIndex: struct {
			field.RelationField
		}{
			RelationField: field.NewRelation("WaterQualityMon.MicroIndex", "pasture.MicroIndex"),
		},
		ToxIndex: struct {
			field.RelationField
		}{
			RelationField: field.NewRelation("WaterQualityMon.ToxIndex", "pasture.ToxIndex"),
		},
		OapGciSla: struct {
			field.RelationField
		}{
			RelationField: field.NewRelation("WaterQualityMon.OapGciSla", "slaughter.OapGciSla"),
		},
		MicroIndexWaterMonSla: struct {
			field.RelationField
		}{
			RelationField: field.NewRelation("WaterQualityMon.MicroIndexWaterMonSla", "slaughter.MicroIndexWaterMonSla"),
		},
		ToxinIndexSla: struct {
			field.RelationField
		}{
			RelationField: field.NewRelation("WaterQualityMon.ToxinIndexSla", "slaughter.ToxinIndexSla"),
		},
	}

	_slaInfoMon.fillFieldMap()

	return _slaInfoMon
}

type slaInfoMon struct {
	slaInfoMonDo slaInfoMonDo

	ALL          field.Asterisk
	ID           field.Uint
	CreatedAt    field.Time
	UpdatedAt    field.Time
	DeletedAt    field.Field
	HouseNumber  field.String
	TimeRecordAt field.String
	WeightMoni   field.Float32
	Stun         slaInfoMonHasOneStun

	BleedElectronic slaInfoMonHasOneBleedElectronic

	AnalAfterSlaQuanCar slaInfoMonHasOneAnalAfterSlaQuanCar

	PreSlaQuanPic slaInfoMonHasOnePreSlaQuanPic

	WaterTempMoni slaInfoMonHasOneWaterTempMoni

	AnalCutWeight slaInfoMonHasOneAnalCutWeight

	TempHumMon slaInfoMonHasOneTempHumMon

	FacDisMon slaInfoMonHasOneFacDisMon

	SlaEnvLigRec slaInfoMonHasOneSlaEnvLigRec

	ToNumGermMon slaInfoMonHasOneToNumGermMon

	AirNumGermMon slaInfoMonHasOneAirNumGermMon

	WaterQualityMon slaInfoMonHasOneWaterQualityMon

	fieldMap map[string]field.Expr
}

func (s slaInfoMon) Table(newTableName string) *slaInfoMon {
	s.slaInfoMonDo.UseTable(newTableName)
	return s.updateTableName(newTableName)
}

func (s slaInfoMon) As(alias string) *slaInfoMon {
	s.slaInfoMonDo.DO = *(s.slaInfoMonDo.As(alias).(*gen.DO))
	return s.updateTableName(alias)
}

func (s *slaInfoMon) updateTableName(table string) *slaInfoMon {
	s.ALL = field.NewAsterisk(table)
	s.ID = field.NewUint(table, "id")
	s.CreatedAt = field.NewTime(table, "created_at")
	s.UpdatedAt = field.NewTime(table, "updated_at")
	s.DeletedAt = field.NewField(table, "deleted_at")
	s.HouseNumber = field.NewString(table, "house_number")
	s.TimeRecordAt = field.NewString(table, "time_record_at")
	s.WeightMoni = field.NewFloat32(table, "weight_moni")

	s.fillFieldMap()

	return s
}

func (s *slaInfoMon) WithContext(ctx context.Context) ISlaInfoMonDo {
	return s.slaInfoMonDo.WithContext(ctx)
}

func (s slaInfoMon) TableName() string { return s.slaInfoMonDo.TableName() }

func (s slaInfoMon) Alias() string { return s.slaInfoMonDo.Alias() }

func (s slaInfoMon) Columns(cols ...field.Expr) gen.Columns { return s.slaInfoMonDo.Columns(cols...) }

func (s *slaInfoMon) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := s.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (s *slaInfoMon) fillFieldMap() {
	s.fieldMap = make(map[string]field.Expr, 19)
	s.fieldMap["id"] = s.ID
	s.fieldMap["created_at"] = s.CreatedAt
	s.fieldMap["updated_at"] = s.UpdatedAt
	s.fieldMap["deleted_at"] = s.DeletedAt
	s.fieldMap["house_number"] = s.HouseNumber
	s.fieldMap["time_record_at"] = s.TimeRecordAt
	s.fieldMap["weight_moni"] = s.WeightMoni

}

func (s slaInfoMon) clone(db *gorm.DB) slaInfoMon {
	s.slaInfoMonDo.ReplaceConnPool(db.Statement.ConnPool)
	return s
}

func (s slaInfoMon) replaceDB(db *gorm.DB) slaInfoMon {
	s.slaInfoMonDo.ReplaceDB(db)
	return s
}

type slaInfoMonHasOneStun struct {
	db *gorm.DB

	field.RelationField
}

func (a slaInfoMonHasOneStun) Where(conds ...field.Expr) *slaInfoMonHasOneStun {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a slaInfoMonHasOneStun) WithContext(ctx context.Context) *slaInfoMonHasOneStun {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a slaInfoMonHasOneStun) Session(session *gorm.Session) *slaInfoMonHasOneStun {
	a.db = a.db.Session(session)
	return &a
}

func (a slaInfoMonHasOneStun) Model(m *slaughter.SlaInfoMon) *slaInfoMonHasOneStunTx {
	return &slaInfoMonHasOneStunTx{a.db.Model(m).Association(a.Name())}
}

type slaInfoMonHasOneStunTx struct{ tx *gorm.Association }

func (a slaInfoMonHasOneStunTx) Find() (result *slaughter.Stun, err error) {
	return result, a.tx.Find(&result)
}

func (a slaInfoMonHasOneStunTx) Append(values ...*slaughter.Stun) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a slaInfoMonHasOneStunTx) Replace(values ...*slaughter.Stun) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a slaInfoMonHasOneStunTx) Delete(values ...*slaughter.Stun) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a slaInfoMonHasOneStunTx) Clear() error {
	return a.tx.Clear()
}

func (a slaInfoMonHasOneStunTx) Count() int64 {
	return a.tx.Count()
}

type slaInfoMonHasOneBleedElectronic struct {
	db *gorm.DB

	field.RelationField
}

func (a slaInfoMonHasOneBleedElectronic) Where(conds ...field.Expr) *slaInfoMonHasOneBleedElectronic {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a slaInfoMonHasOneBleedElectronic) WithContext(ctx context.Context) *slaInfoMonHasOneBleedElectronic {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a slaInfoMonHasOneBleedElectronic) Session(session *gorm.Session) *slaInfoMonHasOneBleedElectronic {
	a.db = a.db.Session(session)
	return &a
}

func (a slaInfoMonHasOneBleedElectronic) Model(m *slaughter.SlaInfoMon) *slaInfoMonHasOneBleedElectronicTx {
	return &slaInfoMonHasOneBleedElectronicTx{a.db.Model(m).Association(a.Name())}
}

type slaInfoMonHasOneBleedElectronicTx struct{ tx *gorm.Association }

func (a slaInfoMonHasOneBleedElectronicTx) Find() (result *slaughter.BleedElectronic, err error) {
	return result, a.tx.Find(&result)
}

func (a slaInfoMonHasOneBleedElectronicTx) Append(values ...*slaughter.BleedElectronic) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a slaInfoMonHasOneBleedElectronicTx) Replace(values ...*slaughter.BleedElectronic) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a slaInfoMonHasOneBleedElectronicTx) Delete(values ...*slaughter.BleedElectronic) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a slaInfoMonHasOneBleedElectronicTx) Clear() error {
	return a.tx.Clear()
}

func (a slaInfoMonHasOneBleedElectronicTx) Count() int64 {
	return a.tx.Count()
}

type slaInfoMonHasOneAnalAfterSlaQuanCar struct {
	db *gorm.DB

	field.RelationField
}

func (a slaInfoMonHasOneAnalAfterSlaQuanCar) Where(conds ...field.Expr) *slaInfoMonHasOneAnalAfterSlaQuanCar {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a slaInfoMonHasOneAnalAfterSlaQuanCar) WithContext(ctx context.Context) *slaInfoMonHasOneAnalAfterSlaQuanCar {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a slaInfoMonHasOneAnalAfterSlaQuanCar) Session(session *gorm.Session) *slaInfoMonHasOneAnalAfterSlaQuanCar {
	a.db = a.db.Session(session)
	return &a
}

func (a slaInfoMonHasOneAnalAfterSlaQuanCar) Model(m *slaughter.SlaInfoMon) *slaInfoMonHasOneAnalAfterSlaQuanCarTx {
	return &slaInfoMonHasOneAnalAfterSlaQuanCarTx{a.db.Model(m).Association(a.Name())}
}

type slaInfoMonHasOneAnalAfterSlaQuanCarTx struct{ tx *gorm.Association }

func (a slaInfoMonHasOneAnalAfterSlaQuanCarTx) Find() (result *slaughter.AnalAfterSlaQuanCar, err error) {
	return result, a.tx.Find(&result)
}

func (a slaInfoMonHasOneAnalAfterSlaQuanCarTx) Append(values ...*slaughter.AnalAfterSlaQuanCar) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a slaInfoMonHasOneAnalAfterSlaQuanCarTx) Replace(values ...*slaughter.AnalAfterSlaQuanCar) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a slaInfoMonHasOneAnalAfterSlaQuanCarTx) Delete(values ...*slaughter.AnalAfterSlaQuanCar) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a slaInfoMonHasOneAnalAfterSlaQuanCarTx) Clear() error {
	return a.tx.Clear()
}

func (a slaInfoMonHasOneAnalAfterSlaQuanCarTx) Count() int64 {
	return a.tx.Count()
}

type slaInfoMonHasOnePreSlaQuanPic struct {
	db *gorm.DB

	field.RelationField
}

func (a slaInfoMonHasOnePreSlaQuanPic) Where(conds ...field.Expr) *slaInfoMonHasOnePreSlaQuanPic {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a slaInfoMonHasOnePreSlaQuanPic) WithContext(ctx context.Context) *slaInfoMonHasOnePreSlaQuanPic {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a slaInfoMonHasOnePreSlaQuanPic) Session(session *gorm.Session) *slaInfoMonHasOnePreSlaQuanPic {
	a.db = a.db.Session(session)
	return &a
}

func (a slaInfoMonHasOnePreSlaQuanPic) Model(m *slaughter.SlaInfoMon) *slaInfoMonHasOnePreSlaQuanPicTx {
	return &slaInfoMonHasOnePreSlaQuanPicTx{a.db.Model(m).Association(a.Name())}
}

type slaInfoMonHasOnePreSlaQuanPicTx struct{ tx *gorm.Association }

func (a slaInfoMonHasOnePreSlaQuanPicTx) Find() (result *slaughter.PreSlaQuanPic, err error) {
	return result, a.tx.Find(&result)
}

func (a slaInfoMonHasOnePreSlaQuanPicTx) Append(values ...*slaughter.PreSlaQuanPic) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a slaInfoMonHasOnePreSlaQuanPicTx) Replace(values ...*slaughter.PreSlaQuanPic) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a slaInfoMonHasOnePreSlaQuanPicTx) Delete(values ...*slaughter.PreSlaQuanPic) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a slaInfoMonHasOnePreSlaQuanPicTx) Clear() error {
	return a.tx.Clear()
}

func (a slaInfoMonHasOnePreSlaQuanPicTx) Count() int64 {
	return a.tx.Count()
}

type slaInfoMonHasOneWaterTempMoni struct {
	db *gorm.DB

	field.RelationField
}

func (a slaInfoMonHasOneWaterTempMoni) Where(conds ...field.Expr) *slaInfoMonHasOneWaterTempMoni {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a slaInfoMonHasOneWaterTempMoni) WithContext(ctx context.Context) *slaInfoMonHasOneWaterTempMoni {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a slaInfoMonHasOneWaterTempMoni) Session(session *gorm.Session) *slaInfoMonHasOneWaterTempMoni {
	a.db = a.db.Session(session)
	return &a
}

func (a slaInfoMonHasOneWaterTempMoni) Model(m *slaughter.SlaInfoMon) *slaInfoMonHasOneWaterTempMoniTx {
	return &slaInfoMonHasOneWaterTempMoniTx{a.db.Model(m).Association(a.Name())}
}

type slaInfoMonHasOneWaterTempMoniTx struct{ tx *gorm.Association }

func (a slaInfoMonHasOneWaterTempMoniTx) Find() (result *slaughter.WaterTempMoni, err error) {
	return result, a.tx.Find(&result)
}

func (a slaInfoMonHasOneWaterTempMoniTx) Append(values ...*slaughter.WaterTempMoni) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a slaInfoMonHasOneWaterTempMoniTx) Replace(values ...*slaughter.WaterTempMoni) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a slaInfoMonHasOneWaterTempMoniTx) Delete(values ...*slaughter.WaterTempMoni) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a slaInfoMonHasOneWaterTempMoniTx) Clear() error {
	return a.tx.Clear()
}

func (a slaInfoMonHasOneWaterTempMoniTx) Count() int64 {
	return a.tx.Count()
}

type slaInfoMonHasOneAnalCutWeight struct {
	db *gorm.DB

	field.RelationField
}

func (a slaInfoMonHasOneAnalCutWeight) Where(conds ...field.Expr) *slaInfoMonHasOneAnalCutWeight {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a slaInfoMonHasOneAnalCutWeight) WithContext(ctx context.Context) *slaInfoMonHasOneAnalCutWeight {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a slaInfoMonHasOneAnalCutWeight) Session(session *gorm.Session) *slaInfoMonHasOneAnalCutWeight {
	a.db = a.db.Session(session)
	return &a
}

func (a slaInfoMonHasOneAnalCutWeight) Model(m *slaughter.SlaInfoMon) *slaInfoMonHasOneAnalCutWeightTx {
	return &slaInfoMonHasOneAnalCutWeightTx{a.db.Model(m).Association(a.Name())}
}

type slaInfoMonHasOneAnalCutWeightTx struct{ tx *gorm.Association }

func (a slaInfoMonHasOneAnalCutWeightTx) Find() (result *slaughter.AnalCutWeight, err error) {
	return result, a.tx.Find(&result)
}

func (a slaInfoMonHasOneAnalCutWeightTx) Append(values ...*slaughter.AnalCutWeight) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a slaInfoMonHasOneAnalCutWeightTx) Replace(values ...*slaughter.AnalCutWeight) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a slaInfoMonHasOneAnalCutWeightTx) Delete(values ...*slaughter.AnalCutWeight) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a slaInfoMonHasOneAnalCutWeightTx) Clear() error {
	return a.tx.Clear()
}

func (a slaInfoMonHasOneAnalCutWeightTx) Count() int64 {
	return a.tx.Count()
}

type slaInfoMonHasOneTempHumMon struct {
	db *gorm.DB

	field.RelationField
}

func (a slaInfoMonHasOneTempHumMon) Where(conds ...field.Expr) *slaInfoMonHasOneTempHumMon {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a slaInfoMonHasOneTempHumMon) WithContext(ctx context.Context) *slaInfoMonHasOneTempHumMon {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a slaInfoMonHasOneTempHumMon) Session(session *gorm.Session) *slaInfoMonHasOneTempHumMon {
	a.db = a.db.Session(session)
	return &a
}

func (a slaInfoMonHasOneTempHumMon) Model(m *slaughter.SlaInfoMon) *slaInfoMonHasOneTempHumMonTx {
	return &slaInfoMonHasOneTempHumMonTx{a.db.Model(m).Association(a.Name())}
}

type slaInfoMonHasOneTempHumMonTx struct{ tx *gorm.Association }

func (a slaInfoMonHasOneTempHumMonTx) Find() (result *slaughter.TempHumMon, err error) {
	return result, a.tx.Find(&result)
}

func (a slaInfoMonHasOneTempHumMonTx) Append(values ...*slaughter.TempHumMon) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a slaInfoMonHasOneTempHumMonTx) Replace(values ...*slaughter.TempHumMon) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a slaInfoMonHasOneTempHumMonTx) Delete(values ...*slaughter.TempHumMon) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a slaInfoMonHasOneTempHumMonTx) Clear() error {
	return a.tx.Clear()
}

func (a slaInfoMonHasOneTempHumMonTx) Count() int64 {
	return a.tx.Count()
}

type slaInfoMonHasOneFacDisMon struct {
	db *gorm.DB

	field.RelationField

	SlaShop struct {
		field.RelationField
		SlaShop8 struct {
			field.RelationField
		}
	}
	DivShop struct {
		field.RelationField
		DivShop8 struct {
			field.RelationField
		}
	}
	AcidShop struct {
		field.RelationField
		AcidShop8 struct {
			field.RelationField
		}
	}
	FroShop struct {
		field.RelationField
		FroShop8 struct {
			field.RelationField
		}
	}
	PackShop struct {
		field.RelationField
		PackShop8 struct {
			field.RelationField
		}
	}
	StaUni struct {
		field.RelationField
		StaUni8 struct {
			field.RelationField
		}
	}
}

func (a slaInfoMonHasOneFacDisMon) Where(conds ...field.Expr) *slaInfoMonHasOneFacDisMon {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a slaInfoMonHasOneFacDisMon) WithContext(ctx context.Context) *slaInfoMonHasOneFacDisMon {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a slaInfoMonHasOneFacDisMon) Session(session *gorm.Session) *slaInfoMonHasOneFacDisMon {
	a.db = a.db.Session(session)
	return &a
}

func (a slaInfoMonHasOneFacDisMon) Model(m *slaughter.SlaInfoMon) *slaInfoMonHasOneFacDisMonTx {
	return &slaInfoMonHasOneFacDisMonTx{a.db.Model(m).Association(a.Name())}
}

type slaInfoMonHasOneFacDisMonTx struct{ tx *gorm.Association }

func (a slaInfoMonHasOneFacDisMonTx) Find() (result *slaughter.FacDisMon, err error) {
	return result, a.tx.Find(&result)
}

func (a slaInfoMonHasOneFacDisMonTx) Append(values ...*slaughter.FacDisMon) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a slaInfoMonHasOneFacDisMonTx) Replace(values ...*slaughter.FacDisMon) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a slaInfoMonHasOneFacDisMonTx) Delete(values ...*slaughter.FacDisMon) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a slaInfoMonHasOneFacDisMonTx) Clear() error {
	return a.tx.Clear()
}

func (a slaInfoMonHasOneFacDisMonTx) Count() int64 {
	return a.tx.Count()
}

type slaInfoMonHasOneSlaEnvLigRec struct {
	db *gorm.DB

	field.RelationField
}

func (a slaInfoMonHasOneSlaEnvLigRec) Where(conds ...field.Expr) *slaInfoMonHasOneSlaEnvLigRec {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a slaInfoMonHasOneSlaEnvLigRec) WithContext(ctx context.Context) *slaInfoMonHasOneSlaEnvLigRec {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a slaInfoMonHasOneSlaEnvLigRec) Session(session *gorm.Session) *slaInfoMonHasOneSlaEnvLigRec {
	a.db = a.db.Session(session)
	return &a
}

func (a slaInfoMonHasOneSlaEnvLigRec) Model(m *slaughter.SlaInfoMon) *slaInfoMonHasOneSlaEnvLigRecTx {
	return &slaInfoMonHasOneSlaEnvLigRecTx{a.db.Model(m).Association(a.Name())}
}

type slaInfoMonHasOneSlaEnvLigRecTx struct{ tx *gorm.Association }

func (a slaInfoMonHasOneSlaEnvLigRecTx) Find() (result *slaughter.SlaEnvLigRec, err error) {
	return result, a.tx.Find(&result)
}

func (a slaInfoMonHasOneSlaEnvLigRecTx) Append(values ...*slaughter.SlaEnvLigRec) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a slaInfoMonHasOneSlaEnvLigRecTx) Replace(values ...*slaughter.SlaEnvLigRec) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a slaInfoMonHasOneSlaEnvLigRecTx) Delete(values ...*slaughter.SlaEnvLigRec) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a slaInfoMonHasOneSlaEnvLigRecTx) Clear() error {
	return a.tx.Clear()
}

func (a slaInfoMonHasOneSlaEnvLigRecTx) Count() int64 {
	return a.tx.Count()
}

type slaInfoMonHasOneToNumGermMon struct {
	db *gorm.DB

	field.RelationField
}

func (a slaInfoMonHasOneToNumGermMon) Where(conds ...field.Expr) *slaInfoMonHasOneToNumGermMon {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a slaInfoMonHasOneToNumGermMon) WithContext(ctx context.Context) *slaInfoMonHasOneToNumGermMon {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a slaInfoMonHasOneToNumGermMon) Session(session *gorm.Session) *slaInfoMonHasOneToNumGermMon {
	a.db = a.db.Session(session)
	return &a
}

func (a slaInfoMonHasOneToNumGermMon) Model(m *slaughter.SlaInfoMon) *slaInfoMonHasOneToNumGermMonTx {
	return &slaInfoMonHasOneToNumGermMonTx{a.db.Model(m).Association(a.Name())}
}

type slaInfoMonHasOneToNumGermMonTx struct{ tx *gorm.Association }

func (a slaInfoMonHasOneToNumGermMonTx) Find() (result *slaughter.ToNumGermMon, err error) {
	return result, a.tx.Find(&result)
}

func (a slaInfoMonHasOneToNumGermMonTx) Append(values ...*slaughter.ToNumGermMon) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a slaInfoMonHasOneToNumGermMonTx) Replace(values ...*slaughter.ToNumGermMon) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a slaInfoMonHasOneToNumGermMonTx) Delete(values ...*slaughter.ToNumGermMon) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a slaInfoMonHasOneToNumGermMonTx) Clear() error {
	return a.tx.Clear()
}

func (a slaInfoMonHasOneToNumGermMonTx) Count() int64 {
	return a.tx.Count()
}

type slaInfoMonHasOneAirNumGermMon struct {
	db *gorm.DB

	field.RelationField
}

func (a slaInfoMonHasOneAirNumGermMon) Where(conds ...field.Expr) *slaInfoMonHasOneAirNumGermMon {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a slaInfoMonHasOneAirNumGermMon) WithContext(ctx context.Context) *slaInfoMonHasOneAirNumGermMon {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a slaInfoMonHasOneAirNumGermMon) Session(session *gorm.Session) *slaInfoMonHasOneAirNumGermMon {
	a.db = a.db.Session(session)
	return &a
}

func (a slaInfoMonHasOneAirNumGermMon) Model(m *slaughter.SlaInfoMon) *slaInfoMonHasOneAirNumGermMonTx {
	return &slaInfoMonHasOneAirNumGermMonTx{a.db.Model(m).Association(a.Name())}
}

type slaInfoMonHasOneAirNumGermMonTx struct{ tx *gorm.Association }

func (a slaInfoMonHasOneAirNumGermMonTx) Find() (result *slaughter.AirNumGermMon, err error) {
	return result, a.tx.Find(&result)
}

func (a slaInfoMonHasOneAirNumGermMonTx) Append(values ...*slaughter.AirNumGermMon) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a slaInfoMonHasOneAirNumGermMonTx) Replace(values ...*slaughter.AirNumGermMon) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a slaInfoMonHasOneAirNumGermMonTx) Delete(values ...*slaughter.AirNumGermMon) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a slaInfoMonHasOneAirNumGermMonTx) Clear() error {
	return a.tx.Clear()
}

func (a slaInfoMonHasOneAirNumGermMonTx) Count() int64 {
	return a.tx.Count()
}

type slaInfoMonHasOneWaterQualityMon struct {
	db *gorm.DB

	field.RelationField

	MicroIndex struct {
		field.RelationField
	}
	ToxIndex struct {
		field.RelationField
	}
	OapGciSla struct {
		field.RelationField
	}
	MicroIndexWaterMonSla struct {
		field.RelationField
	}
	ToxinIndexSla struct {
		field.RelationField
	}
}

func (a slaInfoMonHasOneWaterQualityMon) Where(conds ...field.Expr) *slaInfoMonHasOneWaterQualityMon {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a slaInfoMonHasOneWaterQualityMon) WithContext(ctx context.Context) *slaInfoMonHasOneWaterQualityMon {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a slaInfoMonHasOneWaterQualityMon) Session(session *gorm.Session) *slaInfoMonHasOneWaterQualityMon {
	a.db = a.db.Session(session)
	return &a
}

func (a slaInfoMonHasOneWaterQualityMon) Model(m *slaughter.SlaInfoMon) *slaInfoMonHasOneWaterQualityMonTx {
	return &slaInfoMonHasOneWaterQualityMonTx{a.db.Model(m).Association(a.Name())}
}

type slaInfoMonHasOneWaterQualityMonTx struct{ tx *gorm.Association }

func (a slaInfoMonHasOneWaterQualityMonTx) Find() (result *slaughter.WaterQualityMon, err error) {
	return result, a.tx.Find(&result)
}

func (a slaInfoMonHasOneWaterQualityMonTx) Append(values ...*slaughter.WaterQualityMon) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a slaInfoMonHasOneWaterQualityMonTx) Replace(values ...*slaughter.WaterQualityMon) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a slaInfoMonHasOneWaterQualityMonTx) Delete(values ...*slaughter.WaterQualityMon) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a slaInfoMonHasOneWaterQualityMonTx) Clear() error {
	return a.tx.Clear()
}

func (a slaInfoMonHasOneWaterQualityMonTx) Count() int64 {
	return a.tx.Count()
}

type slaInfoMonDo struct{ gen.DO }

type ISlaInfoMonDo interface {
	gen.SubQuery
	Debug() ISlaInfoMonDo
	WithContext(ctx context.Context) ISlaInfoMonDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() ISlaInfoMonDo
	WriteDB() ISlaInfoMonDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) ISlaInfoMonDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) ISlaInfoMonDo
	Not(conds ...gen.Condition) ISlaInfoMonDo
	Or(conds ...gen.Condition) ISlaInfoMonDo
	Select(conds ...field.Expr) ISlaInfoMonDo
	Where(conds ...gen.Condition) ISlaInfoMonDo
	Order(conds ...field.Expr) ISlaInfoMonDo
	Distinct(cols ...field.Expr) ISlaInfoMonDo
	Omit(cols ...field.Expr) ISlaInfoMonDo
	Join(table schema.Tabler, on ...field.Expr) ISlaInfoMonDo
	LeftJoin(table schema.Tabler, on ...field.Expr) ISlaInfoMonDo
	RightJoin(table schema.Tabler, on ...field.Expr) ISlaInfoMonDo
	Group(cols ...field.Expr) ISlaInfoMonDo
	Having(conds ...gen.Condition) ISlaInfoMonDo
	Limit(limit int) ISlaInfoMonDo
	Offset(offset int) ISlaInfoMonDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) ISlaInfoMonDo
	Unscoped() ISlaInfoMonDo
	Create(values ...*slaughter.SlaInfoMon) error
	CreateInBatches(values []*slaughter.SlaInfoMon, batchSize int) error
	Save(values ...*slaughter.SlaInfoMon) error
	First() (*slaughter.SlaInfoMon, error)
	Take() (*slaughter.SlaInfoMon, error)
	Last() (*slaughter.SlaInfoMon, error)
	Find() ([]*slaughter.SlaInfoMon, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*slaughter.SlaInfoMon, err error)
	FindInBatches(result *[]*slaughter.SlaInfoMon, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*slaughter.SlaInfoMon) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) ISlaInfoMonDo
	Assign(attrs ...field.AssignExpr) ISlaInfoMonDo
	Joins(fields ...field.RelationField) ISlaInfoMonDo
	Preload(fields ...field.RelationField) ISlaInfoMonDo
	FirstOrInit() (*slaughter.SlaInfoMon, error)
	FirstOrCreate() (*slaughter.SlaInfoMon, error)
	FindByPage(offset int, limit int) (result []*slaughter.SlaInfoMon, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) ISlaInfoMonDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (s slaInfoMonDo) Debug() ISlaInfoMonDo {
	return s.withDO(s.DO.Debug())
}

func (s slaInfoMonDo) WithContext(ctx context.Context) ISlaInfoMonDo {
	return s.withDO(s.DO.WithContext(ctx))
}

func (s slaInfoMonDo) ReadDB() ISlaInfoMonDo {
	return s.Clauses(dbresolver.Read)
}

func (s slaInfoMonDo) WriteDB() ISlaInfoMonDo {
	return s.Clauses(dbresolver.Write)
}

func (s slaInfoMonDo) Session(config *gorm.Session) ISlaInfoMonDo {
	return s.withDO(s.DO.Session(config))
}

func (s slaInfoMonDo) Clauses(conds ...clause.Expression) ISlaInfoMonDo {
	return s.withDO(s.DO.Clauses(conds...))
}

func (s slaInfoMonDo) Returning(value interface{}, columns ...string) ISlaInfoMonDo {
	return s.withDO(s.DO.Returning(value, columns...))
}

func (s slaInfoMonDo) Not(conds ...gen.Condition) ISlaInfoMonDo {
	return s.withDO(s.DO.Not(conds...))
}

func (s slaInfoMonDo) Or(conds ...gen.Condition) ISlaInfoMonDo {
	return s.withDO(s.DO.Or(conds...))
}

func (s slaInfoMonDo) Select(conds ...field.Expr) ISlaInfoMonDo {
	return s.withDO(s.DO.Select(conds...))
}

func (s slaInfoMonDo) Where(conds ...gen.Condition) ISlaInfoMonDo {
	return s.withDO(s.DO.Where(conds...))
}

func (s slaInfoMonDo) Order(conds ...field.Expr) ISlaInfoMonDo {
	return s.withDO(s.DO.Order(conds...))
}

func (s slaInfoMonDo) Distinct(cols ...field.Expr) ISlaInfoMonDo {
	return s.withDO(s.DO.Distinct(cols...))
}

func (s slaInfoMonDo) Omit(cols ...field.Expr) ISlaInfoMonDo {
	return s.withDO(s.DO.Omit(cols...))
}

func (s slaInfoMonDo) Join(table schema.Tabler, on ...field.Expr) ISlaInfoMonDo {
	return s.withDO(s.DO.Join(table, on...))
}

func (s slaInfoMonDo) LeftJoin(table schema.Tabler, on ...field.Expr) ISlaInfoMonDo {
	return s.withDO(s.DO.LeftJoin(table, on...))
}

func (s slaInfoMonDo) RightJoin(table schema.Tabler, on ...field.Expr) ISlaInfoMonDo {
	return s.withDO(s.DO.RightJoin(table, on...))
}

func (s slaInfoMonDo) Group(cols ...field.Expr) ISlaInfoMonDo {
	return s.withDO(s.DO.Group(cols...))
}

func (s slaInfoMonDo) Having(conds ...gen.Condition) ISlaInfoMonDo {
	return s.withDO(s.DO.Having(conds...))
}

func (s slaInfoMonDo) Limit(limit int) ISlaInfoMonDo {
	return s.withDO(s.DO.Limit(limit))
}

func (s slaInfoMonDo) Offset(offset int) ISlaInfoMonDo {
	return s.withDO(s.DO.Offset(offset))
}

func (s slaInfoMonDo) Scopes(funcs ...func(gen.Dao) gen.Dao) ISlaInfoMonDo {
	return s.withDO(s.DO.Scopes(funcs...))
}

func (s slaInfoMonDo) Unscoped() ISlaInfoMonDo {
	return s.withDO(s.DO.Unscoped())
}

func (s slaInfoMonDo) Create(values ...*slaughter.SlaInfoMon) error {
	if len(values) == 0 {
		return nil
	}
	return s.DO.Create(values)
}

func (s slaInfoMonDo) CreateInBatches(values []*slaughter.SlaInfoMon, batchSize int) error {
	return s.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (s slaInfoMonDo) Save(values ...*slaughter.SlaInfoMon) error {
	if len(values) == 0 {
		return nil
	}
	return s.DO.Save(values)
}

func (s slaInfoMonDo) First() (*slaughter.SlaInfoMon, error) {
	if result, err := s.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*slaughter.SlaInfoMon), nil
	}
}

func (s slaInfoMonDo) Take() (*slaughter.SlaInfoMon, error) {
	if result, err := s.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*slaughter.SlaInfoMon), nil
	}
}

func (s slaInfoMonDo) Last() (*slaughter.SlaInfoMon, error) {
	if result, err := s.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*slaughter.SlaInfoMon), nil
	}
}

func (s slaInfoMonDo) Find() ([]*slaughter.SlaInfoMon, error) {
	result, err := s.DO.Find()
	return result.([]*slaughter.SlaInfoMon), err
}

func (s slaInfoMonDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*slaughter.SlaInfoMon, err error) {
	buf := make([]*slaughter.SlaInfoMon, 0, batchSize)
	err = s.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (s slaInfoMonDo) FindInBatches(result *[]*slaughter.SlaInfoMon, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return s.DO.FindInBatches(result, batchSize, fc)
}

func (s slaInfoMonDo) Attrs(attrs ...field.AssignExpr) ISlaInfoMonDo {
	return s.withDO(s.DO.Attrs(attrs...))
}

func (s slaInfoMonDo) Assign(attrs ...field.AssignExpr) ISlaInfoMonDo {
	return s.withDO(s.DO.Assign(attrs...))
}

func (s slaInfoMonDo) Joins(fields ...field.RelationField) ISlaInfoMonDo {
	for _, _f := range fields {
		s = *s.withDO(s.DO.Joins(_f))
	}
	return &s
}

func (s slaInfoMonDo) Preload(fields ...field.RelationField) ISlaInfoMonDo {
	for _, _f := range fields {
		s = *s.withDO(s.DO.Preload(_f))
	}
	return &s
}

func (s slaInfoMonDo) FirstOrInit() (*slaughter.SlaInfoMon, error) {
	if result, err := s.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*slaughter.SlaInfoMon), nil
	}
}

func (s slaInfoMonDo) FirstOrCreate() (*slaughter.SlaInfoMon, error) {
	if result, err := s.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*slaughter.SlaInfoMon), nil
	}
}

func (s slaInfoMonDo) FindByPage(offset int, limit int) (result []*slaughter.SlaInfoMon, count int64, err error) {
	result, err = s.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = s.Offset(-1).Limit(-1).Count()
	return
}

func (s slaInfoMonDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = s.Count()
	if err != nil {
		return
	}

	err = s.Offset(offset).Limit(limit).Scan(result)
	return
}

func (s slaInfoMonDo) Scan(result interface{}) (err error) {
	return s.DO.Scan(result)
}

func (s slaInfoMonDo) Delete(models ...*slaughter.SlaInfoMon) (result gen.ResultInfo, err error) {
	return s.DO.Delete(models)
}

func (s *slaInfoMonDo) withDO(do gen.Dao) *slaInfoMonDo {
	s.DO = *do.(*gen.DO)
	return s
}
