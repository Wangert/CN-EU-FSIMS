// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"CN-EU-FSIMS/internal/app/models/pasture"
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"
)

func newDon(db *gorm.DB, opts ...gen.DOOption) don {
	_don := don{}

	_don.donDo.UseDB(db, opts...)
	_don.donDo.UseModel(&pasture.Don{})

	tableName := _don.donDo.TableName()
	_don.ALL = field.NewAsterisk(tableName)
	_don.ID = field.NewUint(tableName, "id")
	_don.CreatedAt = field.NewTime(tableName, "created_at")
	_don.UpdatedAt = field.NewTime(tableName, "updated_at")
	_don.DeletedAt = field.NewField(tableName, "deleted_at")
	_don.PastureFeedMycotoxinsID = field.NewUint(tableName, "pasture_feed_mycotoxins_id")
	_don.Don1 = field.NewFloat64(tableName, "don1")
	_don.Don2 = field.NewFloat64(tableName, "don2")
	_don.Don3 = field.NewFloat64(tableName, "don3")
	_don.Don4 = field.NewFloat64(tableName, "don4")

	_don.fillFieldMap()

	return _don
}

type don struct {
	donDo donDo

	ALL                     field.Asterisk
	ID                      field.Uint
	CreatedAt               field.Time
	UpdatedAt               field.Time
	DeletedAt               field.Field
	PastureFeedMycotoxinsID field.Uint
	Don1                    field.Float64
	Don2                    field.Float64
	Don3                    field.Float64
	Don4                    field.Float64

	fieldMap map[string]field.Expr
}

func (d don) Table(newTableName string) *don {
	d.donDo.UseTable(newTableName)
	return d.updateTableName(newTableName)
}

func (d don) As(alias string) *don {
	d.donDo.DO = *(d.donDo.As(alias).(*gen.DO))
	return d.updateTableName(alias)
}

func (d *don) updateTableName(table string) *don {
	d.ALL = field.NewAsterisk(table)
	d.ID = field.NewUint(table, "id")
	d.CreatedAt = field.NewTime(table, "created_at")
	d.UpdatedAt = field.NewTime(table, "updated_at")
	d.DeletedAt = field.NewField(table, "deleted_at")
	d.PastureFeedMycotoxinsID = field.NewUint(table, "pasture_feed_mycotoxins_id")
	d.Don1 = field.NewFloat64(table, "don1")
	d.Don2 = field.NewFloat64(table, "don2")
	d.Don3 = field.NewFloat64(table, "don3")
	d.Don4 = field.NewFloat64(table, "don4")

	d.fillFieldMap()

	return d
}

func (d *don) WithContext(ctx context.Context) IDonDo { return d.donDo.WithContext(ctx) }

func (d don) TableName() string { return d.donDo.TableName() }

func (d don) Alias() string { return d.donDo.Alias() }

func (d don) Columns(cols ...field.Expr) gen.Columns { return d.donDo.Columns(cols...) }

func (d *don) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := d.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (d *don) fillFieldMap() {
	d.fieldMap = make(map[string]field.Expr, 9)
	d.fieldMap["id"] = d.ID
	d.fieldMap["created_at"] = d.CreatedAt
	d.fieldMap["updated_at"] = d.UpdatedAt
	d.fieldMap["deleted_at"] = d.DeletedAt
	d.fieldMap["pasture_feed_mycotoxins_id"] = d.PastureFeedMycotoxinsID
	d.fieldMap["don1"] = d.Don1
	d.fieldMap["don2"] = d.Don2
	d.fieldMap["don3"] = d.Don3
	d.fieldMap["don4"] = d.Don4
}

func (d don) clone(db *gorm.DB) don {
	d.donDo.ReplaceConnPool(db.Statement.ConnPool)
	return d
}

func (d don) replaceDB(db *gorm.DB) don {
	d.donDo.ReplaceDB(db)
	return d
}

type donDo struct{ gen.DO }

type IDonDo interface {
	gen.SubQuery
	Debug() IDonDo
	WithContext(ctx context.Context) IDonDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IDonDo
	WriteDB() IDonDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IDonDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IDonDo
	Not(conds ...gen.Condition) IDonDo
	Or(conds ...gen.Condition) IDonDo
	Select(conds ...field.Expr) IDonDo
	Where(conds ...gen.Condition) IDonDo
	Order(conds ...field.Expr) IDonDo
	Distinct(cols ...field.Expr) IDonDo
	Omit(cols ...field.Expr) IDonDo
	Join(table schema.Tabler, on ...field.Expr) IDonDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IDonDo
	RightJoin(table schema.Tabler, on ...field.Expr) IDonDo
	Group(cols ...field.Expr) IDonDo
	Having(conds ...gen.Condition) IDonDo
	Limit(limit int) IDonDo
	Offset(offset int) IDonDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IDonDo
	Unscoped() IDonDo
	Create(values ...*pasture.Don) error
	CreateInBatches(values []*pasture.Don, batchSize int) error
	Save(values ...*pasture.Don) error
	First() (*pasture.Don, error)
	Take() (*pasture.Don, error)
	Last() (*pasture.Don, error)
	Find() ([]*pasture.Don, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*pasture.Don, err error)
	FindInBatches(result *[]*pasture.Don, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*pasture.Don) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IDonDo
	Assign(attrs ...field.AssignExpr) IDonDo
	Joins(fields ...field.RelationField) IDonDo
	Preload(fields ...field.RelationField) IDonDo
	FirstOrInit() (*pasture.Don, error)
	FirstOrCreate() (*pasture.Don, error)
	FindByPage(offset int, limit int) (result []*pasture.Don, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IDonDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (d donDo) Debug() IDonDo {
	return d.withDO(d.DO.Debug())
}

func (d donDo) WithContext(ctx context.Context) IDonDo {
	return d.withDO(d.DO.WithContext(ctx))
}

func (d donDo) ReadDB() IDonDo {
	return d.Clauses(dbresolver.Read)
}

func (d donDo) WriteDB() IDonDo {
	return d.Clauses(dbresolver.Write)
}

func (d donDo) Session(config *gorm.Session) IDonDo {
	return d.withDO(d.DO.Session(config))
}

func (d donDo) Clauses(conds ...clause.Expression) IDonDo {
	return d.withDO(d.DO.Clauses(conds...))
}

func (d donDo) Returning(value interface{}, columns ...string) IDonDo {
	return d.withDO(d.DO.Returning(value, columns...))
}

func (d donDo) Not(conds ...gen.Condition) IDonDo {
	return d.withDO(d.DO.Not(conds...))
}

func (d donDo) Or(conds ...gen.Condition) IDonDo {
	return d.withDO(d.DO.Or(conds...))
}

func (d donDo) Select(conds ...field.Expr) IDonDo {
	return d.withDO(d.DO.Select(conds...))
}

func (d donDo) Where(conds ...gen.Condition) IDonDo {
	return d.withDO(d.DO.Where(conds...))
}

func (d donDo) Order(conds ...field.Expr) IDonDo {
	return d.withDO(d.DO.Order(conds...))
}

func (d donDo) Distinct(cols ...field.Expr) IDonDo {
	return d.withDO(d.DO.Distinct(cols...))
}

func (d donDo) Omit(cols ...field.Expr) IDonDo {
	return d.withDO(d.DO.Omit(cols...))
}

func (d donDo) Join(table schema.Tabler, on ...field.Expr) IDonDo {
	return d.withDO(d.DO.Join(table, on...))
}

func (d donDo) LeftJoin(table schema.Tabler, on ...field.Expr) IDonDo {
	return d.withDO(d.DO.LeftJoin(table, on...))
}

func (d donDo) RightJoin(table schema.Tabler, on ...field.Expr) IDonDo {
	return d.withDO(d.DO.RightJoin(table, on...))
}

func (d donDo) Group(cols ...field.Expr) IDonDo {
	return d.withDO(d.DO.Group(cols...))
}

func (d donDo) Having(conds ...gen.Condition) IDonDo {
	return d.withDO(d.DO.Having(conds...))
}

func (d donDo) Limit(limit int) IDonDo {
	return d.withDO(d.DO.Limit(limit))
}

func (d donDo) Offset(offset int) IDonDo {
	return d.withDO(d.DO.Offset(offset))
}

func (d donDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IDonDo {
	return d.withDO(d.DO.Scopes(funcs...))
}

func (d donDo) Unscoped() IDonDo {
	return d.withDO(d.DO.Unscoped())
}

func (d donDo) Create(values ...*pasture.Don) error {
	if len(values) == 0 {
		return nil
	}
	return d.DO.Create(values)
}

func (d donDo) CreateInBatches(values []*pasture.Don, batchSize int) error {
	return d.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (d donDo) Save(values ...*pasture.Don) error {
	if len(values) == 0 {
		return nil
	}
	return d.DO.Save(values)
}

func (d donDo) First() (*pasture.Don, error) {
	if result, err := d.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*pasture.Don), nil
	}
}

func (d donDo) Take() (*pasture.Don, error) {
	if result, err := d.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*pasture.Don), nil
	}
}

func (d donDo) Last() (*pasture.Don, error) {
	if result, err := d.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*pasture.Don), nil
	}
}

func (d donDo) Find() ([]*pasture.Don, error) {
	result, err := d.DO.Find()
	return result.([]*pasture.Don), err
}

func (d donDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*pasture.Don, err error) {
	buf := make([]*pasture.Don, 0, batchSize)
	err = d.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (d donDo) FindInBatches(result *[]*pasture.Don, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return d.DO.FindInBatches(result, batchSize, fc)
}

func (d donDo) Attrs(attrs ...field.AssignExpr) IDonDo {
	return d.withDO(d.DO.Attrs(attrs...))
}

func (d donDo) Assign(attrs ...field.AssignExpr) IDonDo {
	return d.withDO(d.DO.Assign(attrs...))
}

func (d donDo) Joins(fields ...field.RelationField) IDonDo {
	for _, _f := range fields {
		d = *d.withDO(d.DO.Joins(_f))
	}
	return &d
}

func (d donDo) Preload(fields ...field.RelationField) IDonDo {
	for _, _f := range fields {
		d = *d.withDO(d.DO.Preload(_f))
	}
	return &d
}

func (d donDo) FirstOrInit() (*pasture.Don, error) {
	if result, err := d.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*pasture.Don), nil
	}
}

func (d donDo) FirstOrCreate() (*pasture.Don, error) {
	if result, err := d.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*pasture.Don), nil
	}
}

func (d donDo) FindByPage(offset int, limit int) (result []*pasture.Don, count int64, err error) {
	result, err = d.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = d.Offset(-1).Limit(-1).Count()
	return
}

func (d donDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = d.Count()
	if err != nil {
		return
	}

	err = d.Offset(offset).Limit(limit).Scan(result)
	return
}

func (d donDo) Scan(result interface{}) (err error) {
	return d.DO.Scan(result)
}

func (d donDo) Delete(models ...*pasture.Don) (result gen.ResultInfo, err error) {
	return d.DO.Delete(models)
}

func (d *donDo) withDO(do gen.Dao) *donDo {
	d.DO = *do.(*gen.DO)
	return d
}
